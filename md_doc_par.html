<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MPI-AMRVAC: Setting parameters</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="my_customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MPI-AMRVAC
   &#160;<span id="projectnumber">3.1</span>
   </div>
   <div id="projectbrief">The MPI - Adaptive Mesh Refinement - Versatile Advection Code</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Setting parameters </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="par_intro"></a>
Introduction</h1>
<p>This document describes the usage of a <code>.par</code> parameter (input) file for MPI-AMRVAC. For a list of command line options, see <a class="el" href="md_doc_commandline.html">Command line parameters</a>.</p>
<p>Parameters are grouped in namelists according to their functionalities. The namelists have physics-independent class and physics-dependent class. The physics-independent class includes:</p>
<ul>
<li><a class="el" href="md_doc_par.html#par_filelist">Filelist</a> Name and type of files to save (or read)</li>
<li><a class="el" href="md_doc_par.html#par_savelist">Savelist</a> When to save data</li>
<li><a class="el" href="md_doc_par.html#par_stoplist">Stoplist</a> When to stop the simulation</li>
<li><a class="el" href="md_doc_par.html#par_methodlist">Methodlist</a> Which numerical methods to use (e.g., flux scheme, time stepper, time integrator, limiter)</li>
<li><a class="el" href="md_doc_par.html#par_boundlist">Boundlist</a> Boundary conditions</li>
<li><a class="el" href="md_doc_par.html#par_meshlist">meshlist</a> Mesh-related settings (e.g. domain size, refinement)</li>
<li><a class="el" href="md_doc_par.html#par_paramlist">Paramlist</a> Time-step parameters</li>
</ul>
<p>The default parameter values in these namelists are set in <code>src/amrvacio/mod_input_output.t</code>, look at the subroutine <code>read_par_files</code> for details.</p>
<p>The physics-dependent namelists include:</p>
<ul>
<li><a class="el" href="md_doc_par.html#par_rholist">rho list</a> (see also <code><a class="el" href="namespacemod__rho__phys.html" title="Module containing the physics routines for scalar advection.">mod_rho_phys</a></code>)</li>
<li><a class="el" href="md_doc_par.html#par_nonlinearlist">nonlinear list</a> (see also <code><a class="el" href="namespacemod__nonlinear__phys.html" title="Module containing the physics routines for scalar nonlinear equation.">mod_nonlinear_phys</a></code>)</li>
<li><a class="el" href="md_doc_par.html#par_hdlist">HD list</a> (see also <code><a class="el" href="namespacemod__hd__phys.html" title="Hydrodynamics physics module.">mod_hd_phys</a></code>)</li>
<li><a class="el" href="md_doc_par.html#par_mhdlist">MHD list</a> (see also <code><a class="el" href="namespacemod__mhd__phys.html" title="Magneto-hydrodynamics module.">mod_mhd_phys</a></code>)</li>
</ul>
<p>Further namelist are used to control optional modules. Most of these lists are not documented here, but the parameters are described in the corresponding modules:</p>
<ul>
<li><code>rc_list</code> (radiative cooling, see <code><a class="el" href="namespacemod__radiative__cooling.html" title="module radiative cooling â€“ add optically thin radiative cooling for HD and MHD">mod_radiative_cooling</a></code>)</li>
<li><code>tc_list</code> (thermal conduction, see <code><a class="el" href="namespacemod__thermal__conduction.html" title="Thermal conduction for HD and MHD Adaptation of mod_thermal_conduction for the mod_supertimestepping ...">mod_thermal_conduction</a></code>)</li>
<li><code>dust_list</code> (dust, see <code><a class="el" href="namespacemod__dust.html" title="Module for including dust species, which interact with the gas through a drag force.">mod_dust</a></code>)</li>
<li><code>vc_list</code> (viscosity, see <code><a class="el" href="namespacemod__viscosity.html" title="The module add viscous source terms and check time step.">mod_viscosity</a></code>)</li>
<li><code>grav_list</code> (gravity, see <code><a class="el" href="namespacemod__gravity.html" title="Module for including gravity in (magneto)hydrodynamics simulations.">mod_gravity</a></code>)</li>
<li><code>mf_list</code> (magnetofriction, see <code><a class="el" href="namespacemod__mf__phys.html" title="Magnetofriction module.">mod_mf_phys</a></code>)</li>
</ul>
<h2>An example for a namelist</h2>
<p>The parameter file consists of a sequence of namelists, which look like this: </p><pre class="fragment"> &amp;listname
  var_a = value

  ! A comment
  var_b = value
  array = value1, value2, ...
  array(1,1) = value

  ! Repeat value 5 times in array
  array = 5*value
  ...
 /
</pre><p> If you do not define a variable the default value is used.</p>
<p>The Fortran 90 standard for logical variable values is either <code>T</code> and <code>F</code> or <code>.true.</code> and <code>.false.</code>, but some compilers accept only one of them. Text between namelists is ignored, but it may result in a run time error on some machines/compilers.</p>
<p>The following namelist examples contain all the possible variables to set, choices are indicated by <code>|</code>. The first choice is the default value. Only the parameters different from default need to be set. Names that should be replaced are in capital letters. The <code>...</code> indicates optional extra elements for arrays, or extra words in strings.</p>
<h1><a class="anchor" id="par_pidnamelists"></a>
Physics-independent Namelists</h1>
<h2><a class="anchor" id="par_filelist"></a>
Filelist</h2>
<pre class="fragment"> &amp;filelist
   &lt;variable definitions, see below&gt;
 /
</pre><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">name   </th><th class="markdownTableHeadNone">type   </th><th class="markdownTableHeadNone">default   </th><th class="markdownTableHeadNone">description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">base_filename   </td><td class="markdownTableBodyNone">string   </td><td class="markdownTableBodyNone">'data'   </td><td class="markdownTableBodyNone">Base file name for simulation output, which will be followed by a 4-digit number    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">restart_from_file   </td><td class="markdownTableBodyNone">string   </td><td class="markdownTableBodyNone">-   </td><td class="markdownTableBodyNone">Resume from the snapshot data with this file name.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">typefilelog   </td><td class="markdownTableBodyNone">string   </td><td class="markdownTableBodyNone">'default'   </td><td class="markdownTableBodyNone">Use 'regression_test' to do regression test and use the value 'special' to enable user-defined log output    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">snapshotnext   </td><td class="markdownTableBodyNone">integer   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">Start index for writing snapshots    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">slicenext   </td><td class="markdownTableBodyNone">integer   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">Start index for writing slices    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">firstprocess   </td><td class="markdownTableBodyNone">logical   </td><td class="markdownTableBodyNone">F   </td><td class="markdownTableBodyNone">If true, call <code>initonegrid_usr</code> upon restarting    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">reset_grid   </td><td class="markdownTableBodyNone">logical   </td><td class="markdownTableBodyNone">F   </td><td class="markdownTableBodyNone">If true, rebuild the AMR grid upon restarting    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">convert   </td><td class="markdownTableBodyNone">logical   </td><td class="markdownTableBodyNone">F   </td><td class="markdownTableBodyNone">If true and filenameini and snapshotini are given, convert snapshots to other file formats    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">convert_type   </td><td class="markdownTableBodyNone">string   </td><td class="markdownTableBodyNone">vtuBCCmpi   </td><td class="markdownTableBodyNone">Which format to use when converting, options are: tecplot, tecplotCC, vtu, vtuCC, vtuB, vtuBCC, tecplotmpi, tecplotCCmpi, vtuBmpi, vtuBCCmpi, vtumpi, vtuCCmpi, pvtumpi, pvtuCCmpi, tecline, teclinempi, onegrid, EIvtiCCmpi, ESvtiCCmpi, SIvtiCCmpi, EIvtuCCmpi, ESvtuCCmpi, SIvtuCCmpi    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">slice_type   </td><td class="markdownTableBodyNone">string   </td><td class="markdownTableBodyNone">vtu   </td><td class="markdownTableBodyNone">Which format to use when slicing, options are: csv, dat, vtu, vtuCC    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">collapse_type   </td><td class="markdownTableBodyNone">string   </td><td class="markdownTableBodyNone">vti   </td><td class="markdownTableBodyNone">Which format to use when slicing, options are: csv, vti    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">autoconvert   </td><td class="markdownTableBodyNone">logical   </td><td class="markdownTableBodyNone">F   </td><td class="markdownTableBodyNone">If true, already convert to output format during the run    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">sliceascii   </td><td class="markdownTableBodyNone">logical   </td><td class="markdownTableBodyNone">F   </td><td class="markdownTableBodyNone">If true, enable ASCII output of <a class="el" href="md_doc_slices.html">Slice output</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">saveprim   </td><td class="markdownTableBodyNone">logical   </td><td class="markdownTableBodyNone">F   </td><td class="markdownTableBodyNone">If true, convert from conservative to primitive variables in output    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">nwauxio   </td><td class="markdownTableBodyNone">integer   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">Number of auxiliary variables that are only included in the output    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">w_convert_factor   </td><td class="markdownTableBodyNone">double(1:nw)   </td><td class="markdownTableBodyNone">1.0   </td><td class="markdownTableBodyNone">Conversion factors for w variables    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">time_convert_factor   </td><td class="markdownTableBodyNone">double   </td><td class="markdownTableBodyNone">1.0   </td><td class="markdownTableBodyNone">Conversion factor for time unit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">length_convert_factor   </td><td class="markdownTableBodyNone">double   </td><td class="markdownTableBodyNone">1.0   </td><td class="markdownTableBodyNone">Conversion factor for length unit    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>level_io</code>   </td><td class="markdownTableBodyNone">integer   </td><td class="markdownTableBodyNone">-   </td><td class="markdownTableBodyNone">When doing a convert, generate a uniform grid at this level    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>level_io_min</code>   </td><td class="markdownTableBodyNone">integer   </td><td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">Minimum grid level when doing a convert    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>level_io_max</code>   </td><td class="markdownTableBodyNone">integer   </td><td class="markdownTableBodyNone"><code>nlevelshi</code>   </td><td class="markdownTableBodyNone">Maximum grid level when doing a convert    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">nocartesian   </td><td class="markdownTableBodyNone">logical   </td><td class="markdownTableBodyNone">F   </td><td class="markdownTableBodyNone">If true, do not convert the output to a Cartesian coordinate system    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">w_write   </td><td class="markdownTableBodyNone">logical(1:nw)   </td><td class="markdownTableBodyNone">all true   </td><td class="markdownTableBodyNone">VTK: Only write variables for which <code>writew(iw)</code> is true    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">writelevel   </td><td class="markdownTableBodyNone">logical(1:nlevelshi)   </td><td class="markdownTableBodyNone">all true   </td><td class="markdownTableBodyNone">VTK: only write these levels    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">writespshift   </td><td class="markdownTableBodyNone">double(1:ndim,1:2)   </td><td class="markdownTableBodyNone">all zero   </td><td class="markdownTableBodyNone">clip off this relative amount of the domain at the lower and upper side in each dimension   </td></tr>
</table>
<h3>The log file</h3>
<p>By default, the logfile contains one line with a string that is meant to identify the coordinate names, the conserved variables (wnames) and other entries, and then follows a sequence of lines containing numbers: i.e. a single line per requested output time, containing the integer timestep counter <code>it</code>, the time <code>global_time</code>, the time step to be used in the next time advance <code>dt</code>, the domain integrated value of each conserved variable (nw real numbers, which allows to check perfect conservation across the grid tree when the boundary conditions imply it), the percentage of the domain covered by each allowed grid level (given by <code>refine_max_level</code> real numbers between 0.0 and 1.0, with 1.0 indicating 100% coverage: when all numbers are summed, we get 1.0), and the number of grids per allowed grid level (hence, given by <code>refine_max_level</code> integers). The logfile is by default saved as an ASCII file. The order of saving snapshots, and regridding actions is fixed: regrid happens after the advance by one timestep, then regrid, then save the data. This has consequences for the optional variables beyond <em>nwflux</em>.</p>
<h3>Further info on output and postprocessing</h3>
<p>The code can be used to postprocess the MPI-AMRVAC .dat files (which are the only ones to be used for restarts) to some convenient data files for later visualisation purposes. Such conversion of a single .dat file at a time is to be done with the same executable (or at least one compiled on a possibly different machine), on a single processor (i.e. using <em>mpirun -np 1 amrvac</em>). Only selected output types can be converted in parallel, namely those whose name contains 'mpi' as part of the <code>convert_type</code> string. Currently, this includes the ASCII (binary) versions of <code>vtumpi</code> (<code>vtuBmpi</code>) with values located at cell corners and <code>vtuCCmpi</code> (<code>vtuBCCmpi</code>) with values at cell centers, and similarly for tecplot (<code>tecplotmpi</code> or <code>tecplotCCmpi</code>). In addition, <code>pvtumpi</code> (<code>pvtuBmpi</code>) and <code>pvtuCCmpi</code> (<code>pvtuBCCmpi</code>) result in parallel output with one <code>*.vtu</code> file for each processor and a header file from master processor.</p>
<p>In this conversion mode, the idea is to set <code>restart_from_file</code> together with <code>convert=T</code>. You can ask the code during conversion to change from conservative to primitive variable output by setting <code>saveprim=T</code>, and then the corresponding names for the primitive variables are automatically determined. It is also possible to perform the conversion step during run of the simulation with the switch <code>autoconvert=T</code>. Naturally, this leads to more computational overhead and IO, but using the <em>pvtuB(CC)mpi</em> filetype, this can be reduced to a minimum.</p>
<p>For simulations on non-cartesian grids (cylindrical or spherical), there is the option to output the non-cartesian cell coordinates and vector components, which then forces you typically to do the conversion to cell center cartesian grid coordinates and vector variables in your visualization session. By default (i.e. <code>nocartesian=F</code>), the convert module does the conversion from the orthogonal to locally cartesian coordinates and vector components for you. You can overrule this default behavior by setting <code>nocartesian=T</code>. (note: for tecplot format, the coordinate labels are then corrected in the converted file as well).</p>
<p>The only variable that then further matters is <code>convert_type</code>. For type 'tecplot', a corresponding <code>base_filenamexxxx.plt</code> file will be generated, which is an ASCII file that stores the cell corner locations and corner values for the conserved variables, to be handled with Tecplot. The 'onegrid' conversion type is just useful in 1D AMR runs, to generate a single block file (extension '.blk'). Also particular to 1D data, and for TecPlot purposes alone, is the 'tecline' option. This can also be done in parallel mode, where it is called 'teclinempi'.</p>
<p>For visualization using <a href="www.paraview.org">Paraview</a>, the option to convert to &lsquo;convert_type='vtu&rsquo;` can be used. For both <em>vtu</em> and <em>tecplot</em> formats, there are also corresponding <em>vtuCC</em> and <em>tecplotCC</em> options, which store the data with the actually computed cell-centered values. For the <em>vtu</em> and <em>tecplot</em> formats on the other hand, the code tries to already do some interpolation from cell center to cell corner variables for you, but this may introduce some artificial effects in non-cartesian geometries. The <em>vtuB</em> and <em>vtuBCC</em> do the same as <em>vtu(CC)</em> but save the data in binary format.</p>
<p>It is even possible to temporarily add additionally computed auxiliary variables that are instantaneously computable from the data in the <code>base_filenamexxxx.dat</code> file to the converted snapshot. You should then provide the number of such extra variables in <code>nwauxio</code> (see also <a class="el" href="md_doc_mpiamrvac_nw.html">this page</a>), and a corresponding definition for how to compute them from the available <em>nw</em> variables in the associated subroutine <em>usr_special_convert</em> whose default interface is provided in the <em><a class="el" href="mod__usr__methods_8t.html">mod_usr_methods.t</a></em> module. You can there compute variables that are not in your simulation or data file, and store them in the extra slots <em>nw+1:nw+nwauxio</em> of the <em>w</em> variable. For consistency, you should also then add meaningfull names to a string to identify the auxiliary variables, this has to be done in the associated subroutine <em>usr_add_aux_names</em>.</p>
<p>The output values are normally given in code units, i.e. in the dimensionless values used throughout the computation (in the initial condition, we always adhere to the good practice of choosing an appropriate unit of length, time, mass and expressing everything in dimensionless fashion). One can, in the convert stage only, ask to multiply the values by their respective dimensional unit value. <code>time_convert_factor</code> should then be the unit for time, while the array <code>w_convert_factor</code> for w variables and <code>length_convert_factor</code> for length. The corresponding values for conservative entries are computed in <em>convert.t</em> when <em>saveprim=F</em>. See for details of their use the <em>convert.t</em> module.</p>
<p>Note that different formats for postprocess data conversion can be added in the <code>convert.t</code> subroutine. See <a class="el" href="md_doc_convert.html">convert</a> for details.</p>
<p>The <em>VTK</em>-based formats allow for saving only a part of the <em>nw</em> variables, by setting the logical array <code>w_write</code>. The same is true for selecting levels by using the array <code>writelevel</code>. Finally, you can clip away part of the domain, for output in a selected region. This is done by filling the array <code>writespshift</code>. That array should use (consistent) double precision values (between 0 and 1) that specify the percentage of the total domain to be clipped away from the domain boundary at the minimum side, and from the maximum side, respectively, and this for all dimensions. The array has thus a dimensionality _(1:ndim,1:2)_, with the first entry specifying the dimension, and the second whether you clip for minimum (1) and maximum (2) sides, respectively. Note that in the end, only the grids that are fully contained within the clipped region are then converted and stored in the output.</p>
<p>The switches <code>level_io</code>, <code>level_io_min</code> and <code>level_io_max</code> are there to restrict the AMR levels of the output file at the convert stage. These switches do not work with autoconvert. E.g. setting <em>level_io=3</em> will coarsen/refine the data to level 3 everywhere, resulting in a uniform grid. <em>level_io_min</em> limits the minimum level for output by refining levels below level_io_min until level_io_min is reached. Correspondingly, <em>level_io_max</em> limits the maximum level of the output file. This can be useful to visualize large datasets.</p>
<p>The convert types <code>EIvtiCCmpi</code>, <code>ESvtiCCmpi</code>, <code>SIvtiCCmpi</code>, <code>EIvtuCCmpi</code>, <code>ESvtuCCmpi</code> and <code>SIvtuCCmpi</code> are added for synthesize EUV images, EUV spectra and SXR images, where EI represents EUV image, ES represents EUV spectra and SI represents SXR image. The corresponding parameters , e.g. line of sight direction, for synthesizing emissions should be provided in the <a class="el" href="md_doc_par.html#par_emissionlist">Synthetic EUV/SXR/whitelight emission</a> when the convert types are activited.</p>
<h2><a class="anchor" id="par_savelist"></a>
Savelist</h2>
<p>Example: </p><pre class="fragment">&amp;savelist
    itsave(1,1)=0
    itsave(1,2)=0
    dtsave_log=0.01d0 
    dtsave_dat=0.1d0
    dtsave_slice=0.05d0
    dtsave_collapsed=0.05d0
/
</pre><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">name   </th><th class="markdownTableHeadNone">type   </th><th class="markdownTableHeadNone">default   </th><th class="markdownTableHeadNone">description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>ditsave_log</code>   </td><td class="markdownTableBodyNone">integer   </td><td class="markdownTableBodyNone"><code>biginteger</code>   </td><td class="markdownTableBodyNone">Repeatedly save information in a log file when <code>ditsave_log</code> time steps have passed    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>dtsave_dat</code>   </td><td class="markdownTableBodyNone">double   </td><td class="markdownTableBodyNone"><code>bigdouble</code>   </td><td class="markdownTableBodyNone">Repeatedly save dat files when <code>dtsave_dat</code> simulation time has passed    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>itsave(SAVEINDEX,FILEINDEX)</code>   </td><td class="markdownTableBodyNone">integer   </td><td class="markdownTableBodyNone">biginteger   </td><td class="markdownTableBodyNone">Save on these time steps    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>tsave(SAVEINDEX,FILEINDEX)</code>   </td><td class="markdownTableBodyNone">double   </td><td class="markdownTableBodyNone"><code>bigdouble</code>   </td><td class="markdownTableBodyNone">Save on these times    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>nslices</code>   </td><td class="markdownTableBodyNone">integer   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">Number of slices    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>slicedir(INTEGER)</code>   </td><td class="markdownTableBodyNone">integer   </td><td class="markdownTableBodyNone">-   </td><td class="markdownTableBodyNone">Slice direction, see <a class="el" href="md_doc_slices.html">Slice output</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>slicecoord(INTEGER)</code>   </td><td class="markdownTableBodyNone">double   </td><td class="markdownTableBodyNone">-   </td><td class="markdownTableBodyNone">Slice coordinate, see <a class="el" href="md_doc_slices.html">Slice output</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>collapse(INTEGER)</code>   </td><td class="markdownTableBodyNone">logical   </td><td class="markdownTableBodyNone">F   </td><td class="markdownTableBodyNone">See <a class="el" href="md_doc_collapsed.html">Looking at line-integrated quantities</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>collapseLevel</code>   </td><td class="markdownTableBodyNone">integer   </td><td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">See <a class="el" href="md_doc_collapsed.html">Looking at line-integrated quantities</a>   </td></tr>
</table>
<p>Here FILEINDEX has the following meaning:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">index   </th><th class="markdownTableHeadNone">meaning    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">Log output    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">Normal output    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone">Slice output, see <a class="el" href="md_doc_slices.html">Slice output</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyNone">Collapsed output, see <a class="el" href="md_doc_collapsed.html">Looking at line-integrated quantities</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">5   </td><td class="markdownTableBodyNone">Call user custom analysis subroutine, see <a class="el" href="md_doc_analysis.html">Writing a custom analysis subroutine</a>   </td></tr>
</table>
<p>One may want to save snapshots more frequently at the beginning of the simulation. E.g. <code>tsave(1,2)=0.1 tsave(2,2)=0.25 tsave(3,2)=0.5 dtsave_dat=0.5</code> could be used to save snapshots at times 0.1, 0.25, 0.5, 1, 1.5, ... etc.</p>
<p>If no save condition is given for a file you get a warning, but the final output is always saved after the stop condition has been fulfilled. If <code>itsave(1,2)=0</code> is set, the initial state is saved before advancing.</p>
<h2><a class="anchor" id="par_stoplist"></a>
Stoplist</h2>
<pre class="fragment">&amp;stoplist
    it_max =INTEGER
    time_max =DOUBLE
    wall_time_max =DOUBLE
    dtmin =DOUBLE
    it_init =INTEGER
    time_init =DOUBLE
    reset_time =F | T
    reset_it   =F | T
    final_dt_reduction=T | F
/
</pre> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">name   </th><th class="markdownTableHeadNone">type   </th><th class="markdownTableHeadNone">default   </th><th class="markdownTableHeadNone">description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>it_max</code>   </td><td class="markdownTableBodyNone">integer   </td><td class="markdownTableBodyNone"><code>biginteger</code>   </td><td class="markdownTableBodyNone">a run ends when the number of time steps reaches it    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>time_max</code>   </td><td class="markdownTableBodyNone">double   </td><td class="markdownTableBodyNone"><code>bigdouble</code>   </td><td class="markdownTableBodyNone">a run ends when the physical time reaches it    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>wall_time_max</code>   </td><td class="markdownTableBodyNone">double   </td><td class="markdownTableBodyNone"><code>bigdouble</code>   </td><td class="markdownTableBodyNone">a run ends when the wall time reaches it (in hours)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>dtmin</code>   </td><td class="markdownTableBodyNone">double   </td><td class="markdownTableBodyNone"><code>bigdouble</code>   </td><td class="markdownTableBodyNone">a run stops when time step falls smaller than it    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>it_init</code>   </td><td class="markdownTableBodyNone">integer   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">set the initial number of time steps when start a new run    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>time_init</code>   </td><td class="markdownTableBodyNone">double   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">set the initial time when start a new run    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>reset_time</code>   </td><td class="markdownTableBodyNone">logical   </td><td class="markdownTableBodyNone">F   </td><td class="markdownTableBodyNone">when restart from a previous run, reset the time to the initial one if it is T    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>reset_it</code>   </td><td class="markdownTableBodyNone">logical   </td><td class="markdownTableBodyNone">F   </td><td class="markdownTableBodyNone">when restart from a previous run, reset the number of time steps to the initial one if it is T    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>final_dt_reduction</code>   </td><td class="markdownTableBodyNone">logical   </td><td class="markdownTableBodyNone">T   </td><td class="markdownTableBodyNone">forces the last dt to comply with time_max limit   </td></tr>
</table>
<p>You may use an upper limit <code>it_max</code> for the number of timesteps, and/or the physical time <code>time_max</code>, and/or the wall time 'wall_time_max' to end a run. The wall time means wall clock time recording real-world time.</p>
<p>Numerical or physical instabilities may produce huge changes or very small time steps depending on the way <code>dt</code> is determined. These breakdowns can be controlled by either setting a lower limit <code>dtmin</code> for the physical time step, which is useful when <code>dt</code> is determined from the <code>courantpar</code> parameter. If a run stops due to <code>dt &lt; dtmin</code>, a warning message is printed.</p>
<p>You have to specify at least one of <code>time_max, it_max</code>. AMRVAC stops execution when any of the limits are exceeded. The initial time value <code>time_init</code> and integer time step counter <code>it_init</code> values, which are zero by default, can be specified here. However, when a restart is performed from a previous .dat file, the values in that file will be used unless you reset them to their initial values by setting <code>reset_time=T</code>. If you want only to reset the iteration count without changing time, set <code>reset_it=T</code>.</p>
<h2><a class="anchor" id="par_methodlist"></a>
Methodlist</h2>
<pre class="fragment">&amp;methodlist

time_stepper='twostep' | 'onestep' | 'threestep' | 'fourstep' | 'fivestep'
time_integrator= choices depends on time_stepper
flux_scheme=nlevelshi strings from: 'hll'|'hllc'|'hlld','hllcd'|'tvdlf'|'tvdmu'|'tvd'|'cd'|'fd'|'source'|'nul'
limiter= nlevelshi strings from: 'minmod' | 'woodward' | 'superbee' | 'vanleer' | 'albada' | 'ppm' | 'mcbeta' | 'koren' | 'cada' | 'cada3' | 'mp5' | 'schmid1' | 'schimid2' | 'venk' | 'weno3' | 'wenoyc3' | 'weno5' | 'weno5nm'| 'wenoz5' | 'wenoz5nm' | 'wenozp5' | 'wenozp5nm' | 'weno5cu6' | 'teno5ad' | 'weno7' | 'mpweno7'
gradient_limiter= nlevelshi strings from: 'minmod' | 'woodward' | 'superbee' | 'vanleer' | 'albada' | 'ppm' | 'mcbeta' | 'koren' | 'cada' | 'cada3'
loglimit= nw logicals, all false by default
flatsh = F | T
flatcd = F | T
mcbeta= DOUBLE

typeentropy= 'nul'|'powell'|'harten'|'ratio'|'yee'
entropycoef= DOUBLE, DOUBLE, DOUBLE, ....

typetvd= 'roe' | 'yee' | 'harten' | 'sweby'
typeaverage='default' | 'roe' | 'arithmetic'

typeboundspeed= 'Einfeldt' | 'cmaxmean' | 'cmaxleftright'
tvdlfeps = DOUBLE

flathllc= F | T
nxdiffusehllc = INTEGER

source_split_usr= F | T
typesourcesplit= 'sfs' | 'sf' | 'ssfss' | 'ssf'
dimsplit= F | T
typedimsplit= 'default' | 'xyyx'| 'xy'

small_density= DOUBLE
small_pressure= DOUBLE
small_temperature= DOUBLE
small_values_method='error' | 'replace' | 'average'
small_values_daverage=1
check_small_values= F | T
fix_small_values= F | T
trace_small_values= F | T
small_values_fix_iw= LOGICAL, LOGICAL, LOGICAL, ...

typegrad = 'central' | 'limited'
typediv = 'central' | 'limited'
typecurl = 'central' | 'Gaussbased' | 'Stokesbased'
/
</pre> <h3><a class="anchor" id="par_time_integrator"></a>
time_stepper, time_integrator, flux_scheme</h3>
<p>The <code>time_stepper</code> variable determines the time integration procedure. The default procedure is a second order predictor-corrector type 'twostep' scheme (suitable for TVDLF, TVD-MUSCL schemes), and a simple 'onestep' algorithm for the temporally second order TVD method, or the first order TVDLF1, TVDMU1, TVD1 schemes. It is not possible to mix different step size methods across the AMR grid levels. The temporally first order but spatially second order TVD1 algorithm is best suited for steady state calculations as a 'onestep' scheme. The TVDLF and TVD-MUSCL schemes can be forced to be first order, and linear in the time step, which is good for getting a steady state, by setting &lsquo;time_stepper='onestep&rsquo;`.</p>
<p>There is also a fourth order Runge-Kutta type method, when &lsquo;time_stepper='fourstep&rsquo;` and one sets &lsquo;time_integrator='rk4&rsquo;`. It can be used with <em>dimsplit=.true.</em>. These higher order time integration methods can be most useful in conjunction with higher order spatial discretizations. See also <a class="el" href="md_doc_discretization.html">discretization</a> and <a class="el" href="md_doc_time_discretization.html">time_discretization</a>.</p>
<p>The array <code>flux_scheme</code> defines a scheme to calculate the flux at cell interfaces using the chosen <a class="el" href="md_doc_methods.html">method</a> (like hll based approximate Riemann solver) per activated grid level (and on each level, all variables use the same discretization). In total, <em>nlevelshi</em> methods must be specified, by default <em>nlevelshi=20</em> and these are then all set by <em>flux_scheme=20*'tvdlf'</em>. Different discretizations can be mixed across the <em>refine_max_level</em> activated grid levels (but the same stepping scheme must apply for all of the schemes).</p>
<p>Setting for a certain level the flux_scheme to 'nul' implies doing no advance at all, and 'source' merely adds sources. These latter two values must be used with care, obviously, and are only useful for testing source terms or to save computations when fluxes are known to be zero.</p>
<h3><a class="anchor" id="par_typelimiter"></a>
Limiter type</h3>
<p>For the TVDLF and TVD-MUSCL methods different limiter functions can be defined for the limited linear reconstructions from cell-center to cell-edge variables, and for the TVD method, for the characteristic variables. The default limiter is the most diffusive &lsquo;limiter=nlevelshi*'minmod&rsquo;` limiter (minmod for all levels), but one can also use &lsquo;limiter=nlevelshi*'woodward&rsquo;`, or use different limiters per level. Click <a class="el" href="md_doc_limiter.html">Slope limiters</a> to see detailed description of all available limiters.</p>
<p>The <code>gradient_limiter</code> is the selection of a limiter to be used in computing gradients (or divergence of vector) when the typegrad=limited (or typediv=limited) is selected. It is thus only used in the gradientS (divvectorS) subroutines in geometry.t and has effect for the magnetohydrodynamics (MHD) modules.</p>
<p>When having a gravitational stratification, one might benefit from performing linear reconstruction on the primitive variables log10(rho) and/or log10(p). This can be done by setting the corresponding <em>loglimit(iw)=T</em> with <em>iw</em> the label of the corresponding component in the <em>w</em> array (for density, this is thus <em>iw=1</em>).</p>
<p>When using PPM as a limiter, minor differences can be obtained using the switches flatcd and flatsh. These are meant to minimize potential ripples around contact discontuinities (flatcd) or shocks (flatsh), but one should first try without these flattenings (default behavior). PPM is actually only used in a quadratic reconstruction from center to edge, requires the use of a larger stencil (nghostcells=3), and can be used either in the methods (by setting limiter) or in the gradientS/divvectorS routines (when typegrad or typediv is limited, and gradient_limiter is ppm) in geometry.t. If <em>flatcd=T</em> or <em>flatsh=T</em> to flattern oscillations at contact discontuinities or shocks, it needs 1 more ghost cell, e.g., nghostcells=4.</p>
<h3><a class="anchor" id="par_typeentropy"></a>
Typeentropy, entropycoef</h3>
<p>For Riemann solver based methods, such as TVD and TVD-MUSCL (but not TVDLF), an entropyfix may be applied to avoid unphysical solutions. The fix is applied to the characteristic variables. The default entropy fix is &lsquo;'nul&rsquo;`, i.e. no entropy fix. When an expansion shock is formed, the entropy fix should be applied to the non-degenerate characteristic waves, i.e. waves that can form shocks (sound waves, fast and slow magnetosonic waves). The most powerful entropy fix is called 'powell'. In practice, one may apply an entropy fix to all characteristic waves, usually the slight extra diffusion makes the schemes more robust. For Yee entropyfix the minimum characteristic speed (normalized by dt/dx) can be set for each characteristic wave using the <code>entropycoef</code> array.</p>
<h3><a class="anchor" id="par_tvdvariants"></a>
Different TVD variants</h3>
<p>Both <code>tvd</code> and <code>tvdlf</code> have a few variants, these can be set in the strings <code>typetvd</code> and <code>typeboundspeed</code>, with defaults 'roe' and 'Einfeldt', respectively. The default &lsquo;typetvd='roe&rsquo;&lsquo; is the fastest of the four upwind types. For the TVDLF, the 'cmaxmean&rsquo; merely means whether the maximal physical propagation speed is determined as the maximum speed for the mean state based on averaging left centered and right centered states, or by taking the Roe average eigenvalues for the left and right nonlinear waves proposed by Einfeldt (Einfeldt 1988 J. Numer. Anal.). In the TVDLF flux, the diffuse flux part has a coefficient <code>tvdlfeps</code> which is 1 by default. For steady- state computations, one may gain in shock sharpness by reducing this factor to a positive value smaller than 1.</p>
<p><em>Only for the adiabatic hydro module</em>, the option to select an arithmetic, or a roe average is available for use in the roe solver. This is set by the <code>typeaverage</code>.</p>
<p>Just like in the TVDLF method, the slightly more involved HLL method has a diffuse flux part with coefficient <code>tvdlfeps</code> which is 1 by default. For steady-state computations, one may gain in shock sharpness by reducing this factor to a positive value smaller than 1.</p>
<p>When using the HLLC scheme variants, for HD, MHD there is an optional additional flattening in case the characteristic speed at the contact is near zero. This is activated by setting <code>flathllc=T</code> (its default is false). One can also solve some potential noise problems in the HLLC by switching to the HLLCD variant, a kind of mix between HLLC and TVDLF. The TVDLF is then used in a user-controlled region around a point where there is a sign change in flux, whose width is set by <code>nxdiffusehllc</code> (an integer which is 0 by default).</p>
<h3><a class="anchor" id="par_dimsplit"></a>
Dimensional splitting</h3>
<p>Special sources, if any, can be added in a split or unsplit way according to the logical variables <code>source_split_usr</code> The default value is false meaning these sources are added in an unsplit way by default. The split sources are added according to <code>typesourcesplit</code>. The meaning of the different options for <code>typesourcesplit</code> is described in <a class="el" href="md_doc_discretization.html#disc-splitting">discretization</a>. Under default settings, we use unsplit sources only, and if one reverts to split sources, &lsquo;typesourcesplit='sfs&rsquo;`.</p>
<p>In multidimensional calculations dimensional splitting can be used by setting <code>dimsplit=T</code>, with an alternating order of the sweeps &lsquo;typedimsplit='xyyx&rsquo;<code>by default. It is best to use </code>dimsplit=F`, the default value, but the TVD method needs a dimensionally split strategy. The limitations on using dimensionally unsplit methods are described in <a class="el" href="md_doc_methods.html">methods</a>.</p>
<h3><a class="anchor" id="par_positivityfix"></a>
Positivity fixes</h3>
<p>Negative pressure or density caused by the numerical approximations can make the code crash. For HD and MHD modules this can be monitored or even cured by the handle_small_values subroutines in each substep of iteration. The control parameters small_density, small_pressure, small_temperature play a role here: they can be set to small positive values but not negative values, while their default is 0. If small_temperature is positive, small_pressure is overwritten by the product of small_rho and small_temperature. If check_small_values is set to .true., an additional check for small values will be triggered in phys_get_pthermal. NOTE: If small values are detected then a crash will occur regardless of whether any other positivity fixes are enabled. If fix_small_values is set to .true., small values are actually treated or fixed in subroutines such as phys_to_primitive, phys_to_conserved and source terms like resistive terms in MHD.</p>
<p>The actual treatment is determined by the small_values_method parameter: Its default value 'error' causes a full stop in the handle_small_values subroutine in the physics modules. In this way, you can use it for debugging purposes, to spot from where the actual negative pressure and unphysical value gets introduced during which call. If the compilation is in debug mode and trace_small_value=T, then the error message shows the path of execution as number of lines of subroutines so that you know when the small values are encountered in the execution sqeuence. If it is somehow unavoidable in your simulations, then you may rerun with a recovery process turned on as follows. When small_values_method='replace', the parameters small_pressure, small_density are used to replace any unphysical value and set momentum to be 0, as encoded in <code><a class="el" href="mod__small__values_8t.html">mod_small_values.t</a></code>. When you select small_values_method='average', any unphysical value is replaced by averaging from a user-controlled environment about the faulty cells. The width of this environment in cells is set by the integer small_values_daverage. The parameter small_values_fix_iw is an array, containing a logical for each variable. It has a length nw. It can be used to make sure that a certain variable is not adjusted by the small_values_method. The default is true for all the variables. If the user sets it to false for a given variable, that variable will not be adjusted by the small_values_method. The first elements are the logicals for the conservative variables in their standard order. As an example: if the user would like to adjust the pressure and density but not the momentum in a 2D MHD simulation, then small_values_fix_iw has to be set to T, F, F, T, T, T.</p>
<h3><a class="anchor" id="par_process"></a>
Special process</h3>
<p>User controlled special process can be added to each iteration. Subroutine usr_process_grid can be registered in mod_usr.t to process for each grid. Subroutine usr_process_global can be registered in mod_usr.t to do global process. For example, you can do computations of non-local auxiliary variables (like the divergence of some vector fields, time integrals etc).</p>
<p>The <code>typegrad</code> can be selected to switch from simple centered differencing on the cell center values, to limited reconstruction followed by differencing when computing gradients. They call either of <em>gradient</em> ('central') or <em>gradientS</em> ('limited') subroutines that are themselves found in the <em>geometry.t</em> module. Similarly, a switch for the divergence of a vector is the <code>typediv</code> switch. When the 'limited' variant is used, one must set the corresponding gradient_limiter array to select a limiter (per level).</p>
<h2><a class="anchor" id="par_boundlist"></a>
Boundlist</h2>
<pre class="fragment">&amp;boundlist
 nghostcells= INTEGER
 typeboundary_min^D= 'cont'|'symm'|'asymm'|'periodic'|'special'|'noinflow'
 typeboundary_max^D= 'cont'|'symm'|'asymm'|'periodic'|'special'|'noinflow'
 internalboundary = F | T
 ghost_copy= F | T
/
</pre><p> The boundary types have to be defined for each <b>conserved variable</b>, except for psi (in GLM-MHD) and tracer fluids, at each physical edge of the grid. For 2D hydrodynamics they are: rho,m1,m2,e at the left boundary (typeboundary_min1); rho,m1,m2,e at the right (typeboundary_max1); rho,m1,m2,e at the bottom (typeboundary_min2); rho,m1,m2,e at the top boundary (typeboundary_max2). Boundary types of psi (in GLM-MHD) and tracer fluids are automatically set to be the same as boundary type of density by default. Boundary types of dust density and dust momentum still must be set manually by user, if dust module is activated. The general subroutine devoted to the treatment of boundary conditions (either customized by the user or not, internal or external to the simulation space, polar or not) is <em>get_bc</em> and the main files concerned are <em><a class="el" href="mod__ghostcells__update_8t.html">mod_ghostcells_update.t</a></em> and <em>boundary_conditions.t</em>. Since the pre-defined boundary conditions are applied to the conserved variables, it does not guarantee the continuity of the fluxes (i.e. the terms associated to the velocity within the divergences in the fundamental equations under their conservative form, see <a class="el" href="md_doc_equations.html">equations.md</a>) and can prevent the fluid from reaching a steady state. For instance, a conserved total specific intern energy (i.e. intern plus kinetic energy) <em>e</em> does not result, in general, in a conserved flux of the variable carried by the velocity field i.e. <em>e+P</em>, where <em>P</em> is the pressure. Without a source term, it means that the time variation of <em>e</em> can not cancel out.</p>
<p>Instead of manually specifying one by one the boundary conditions, the user can write <em>8*'X'</em> to replace _'X'_ 8 times in a row for instance. Beware, it is simply a syntax substitution rule which does not tell anything about the number of variables nor the number of dimensions. To improve readability, users are invited to highlight this underlying structure in the instructions. For instance, in a two dimensional hydrodynamical simulation space (<em>ndim=2</em>) with the mass density, three components of the velocity field (<em>ndir=3</em>) and an energy equation, if the bottom boundary is a plane of symmetry, the upper boundary is opened and the lateral boundaries are periodic, we would write : </p><pre class="fragment">&amp;boundlist
 typeboundary_min1= 5*'periodic'
 typeboundary_max1= 5*'periodic'
 typeboundary_min2= 'symm','symm','asymm','symm','symm'
 typeboundary_max2= 5*'cont'
/
</pre><p> The default number of ghost cell layers used to surround the grid (and in fact each grid at each level and location) is set by default to <code>nghostcells=2</code> and automatically increased if larger stencil is needed for high-order reconstructions. For example, when <code>limiter=mp5</code> it takes 3, and <code>limiter=ppm</code> makes it 4.</p>
<p>The default boundary type is <code>cont</code> for all variables and edges, it means that the gradient (of the conservative variables) is kept zero by copying the variable values from the edge of the mesh into the ghost cells.</p>
<p>Other predefined types are the <code>symm</code> and <code>asymm</code> types, which are mostly used for reflective boundaries, or at symmetry axes of the domain (the polar or equatorial axis, e.g.). One then typically makes the momentum orthogonal to the given boundary antisymmetric (<code>asymm</code>), the rest of the variables <code>symm</code>. These boundary types can also be used to represent a perfectly conducting wall (the orthogonal component of the magnetic field should be antisymmetric, the transverse component symmetric) or the physical symmetry of the physical problem. More generally, true (a.k.a. polar) vectors (resp. pseudovectors, a.k.a. axial vectors) such as the ones associated to a velocity (resp. magnetic) field, transform such as the normal component (resp. the tangential components) is antisymmetric while the tangential components (resp. the normal component) are symmetric with respect to a plane of symmetry of causes (distribution of mass, of currents, of charges, etc). And vice versa for a plane of antisymmetry.</p>
<p>If the pole is adjacent to the simulation space (i.e. if the simulation extends down to a distance to the axis of 0 in cylindrical coordinates and if the simulation extends down to a colatitude of 0 or up to a colatitude of pi in spherical coordinates), symm and/or asymm boundary conditions must necessarily be specified. Scalar quantities are always symmetric. For a vector, whatever its nature (true vector or pseudovector), the boundary condition to choose for a given component depends on the behaviour of the axis vector associated to this component when a rotation of pi is performed within the plane orthogonal to the pole. In cylindrical coordinates, it means that the radial and vertical components should be symmetric while the orthoradial component is antisymmetric. In spherical coordinates, it means that the radial component is symmetric while the two remaining components are antisymmetric. For 3D cylindrical and spherical grid computations, the singular polar axis is trivially handled using a so-called pi-periodic boundary treatment, where periodicity across the pole comes from the grid cell diagonally across the pole, i.e. displaced over pi instead of 2 pi. These are automatically recognized from the coordinate setting, and the corresponding range in angle phi must span 2 pi for cylindrical, and theta must then start at zero (to include the north pole) and/or end at pi (for the south pole) for spherical grids. The user just needs to set the typeboundary as typeboundary_min2=8*'pole' and/or typeboundary_max2=8*'pole' in 3D spherical coordinates or typeboundary_min1=8*'pole' in cylindrical/polar coordinates, or use symmetry boundary (using symm and asymm combinations).</p>
<p>The case of periodic boundaries can be handled with setting 'periodic' for all variables at both boundaries that make up a periodic pair. Hence triple periodic in 3D MHD where 8 variables are at play means setting </p><pre class="fragment">typeboundary_min1=8*'periodic'
typeboundary_max1=8*'periodic'
typeboundary_min2=8*'periodic'
typeboundary_max2=8*'periodic'
typeboundary_min3=8*'periodic'
typeboundary_max3=8*'periodic'
</pre><p>The possibility exists to put a boundary condition mimicking zero across the computational boundary, by selecting <em>typeboundary='noinflow'</em> for the momentum vector components of your particular application. This is in principle only relevant for the momentum component locally perpendicular to the boundary (for others a continuous extrapolation is done). The <em>noinflow</em> extrapolates values that are outwardly moving continuously, while clipping all values that are inwardly advecting momentum to zero.</p>
<p>The <code>special</code> type is to be used for setting fixed values, or any time dependent or other more complicated boundary conditions, and results in a call to the <code>usr_special_bc</code> subroutine which has to be provided by the user in the <em>mod_usr.t</em> module. The variables with <code>special</code> boundary type are updated last within a given boundary region, thus the subroutine may use the updated values of the other variables. The order of the variables is fixed by the equation module chosen, i.e. <em>rho m1 m2 m3 e b1 b2 b3</em> for 3D MHD. It is suggested to set all typeboundary entries for a certain boundary region to <code>special</code> to consistently fill the boundary info for all variables in a user-defined manner.</p>
<p>Internal boundaries can be used to overwrite the domain variables with specified values through <em>usr_internal_bc</em> subroutine. This is activated with the switch <code>internalboundary=T</code>. Internally, these are assigned before the ghost-cells and external boundaries are applied (in subroutine get_bc).</p>
<p>The <code>ghost_copy=F</code> implies the use of limited linear reconstructions in the filling of ghost cells for internal boundaries that exist due to the AMR hierarchy. If <code>ghost_copy=T</code>, a first order 'copy' is used 'unlimit'. To retain second order accuracy, the default set is needed.</p>
<h2><a class="anchor" id="par_meshlist"></a>
meshlist</h2>
<pre class="fragment">&amp;meshlist
 refine_max_level= INTEGER
 domain_nx1= INTEGER
 domain_nx2= INTEGER
 domain_nx3= INTEGER
 block_nx1= INTEGER
 block_nx2= INTEGER
 block_nx3= INTEGER
 xprobmin1= DOUBLE
 xprobmax1= DOUBLE
 xprobmin2= DOUBLE
 xprobmax2= DOUBLE
 xprobmin3= DOUBLE
 xprobmax3= DOUBLE
 refine_criterion= INTEGER
 nbufferx1= INTEGER
 nbufferx2= INTEGER
 nbufferx3= INTEGER
 max_blocks= INTEGER
 amr_wavefilter= nlevelshi DOUBLE values
 refine_threshold= nlevelshi DOUBLE values
 derefine_ratio= nlevelshi DOUBLE values
 w_refine_weight= DOUBLE array nw+1 values that must sum up to 1.0d0
 logflag= nw logical values, all F by default
 iprob= INTEGER
 prolongprimitive= F | T
 coarsenprimitive= F | T
 tfixgrid= DOUBLE
 itfixgrid= INTEGER
 ditregrid= INTEGER
 stretch_dim= ndim STRING values ('uni','symm','none')
 stretch_uncentered = F | T
 qstretch_baselevel= DOUBLE
 nstretchedblocks_baselevel= INTEGER
/
</pre> <h3><a class="anchor" id="par_refine_max_level"></a>
refine_max_level, max_blocks, domain_nx^D, block_nx^D, xprobmin^D, xprobmax^D</h3>
<p><code>refine_max_level</code> indicates the maximum number of grid levels that can be used during the simulation, including the base grid level. It is an integer value which is maximally equal to the parameter <em>nlevelshi</em> and minimally equal to 1. The parameter <em>nlevelshi=20</em> by default, a value set in <em><a class="el" href="mod__global__parameters_8t.html">mod_global_parameters.t</a></em>, so that if more than 20 levels are to be used, one must change this value and recompile. Note that when <em>refine_max_level&gt;1</em>, it is possible that during runtime, the highest grid level is temporarily lower than refine_max_level, and/or that the coarsest grid is at a higher level than the base level. The number of grid blocks in each processor has an upper limit defined by <code>max_blocks</code> which is 4000 by default and can be set to higher numbers if too many blocks in a processor are allocated.</p>
<p>The computational domain is set by specifying the minimal and maximal coordinate value per direction in the <em>xprob^L</em> settings. When cylindrical or spherical coordinates are selected, the angle ranges (for phi in the cylindrical case, and for both theta and phi in the spherical case) are to be given in 2 pi units.</p>
<p>The base grid resolution (i.e. on the coarsest level 1) is best specified by providing <em>domain_nx^D</em>, the number of grid cells per dimension, to cover the full computational domain set by the <em>xprobmin^D</em> and <em>xprobmax^D</em>. The resolution of each grid block is set by <em>block_nx^D</em> which exclude ghost cells at each side. The <em>domain_nx^D</em> must thus be a integer multiple of <em>block_nx^D</em>. The number of blocks on level 1 in a dimension, which does not have any pole or periodic boundary, must be larger than 1 for a rectanuglar mesh with more than one level because of the limitation from ghost-cell exchange at physical boundaries.</p>
<h3><a class="anchor" id="par_errest"></a>
refine_criterion, nbufferx^D, amr_wavefilter</h3>
<p>The code offers various choices for the error estimator used in automatically detecting regions that need refinement.</p>
<p>When <code>refine_criterion=1</code>, all refinement will only be based on the user- defined criteria to be coded up in subroutine <em>specialrefine_grid</em>.</p>
<p>When <code>refine_criterion=3</code>, the default value, errors are estimated using current t_n values and their gradients following Lohner prescription. In this scheme, the <code>amr_wavefilter</code> coefficient can be adjusted from its default value 0.01d0. You can set different values for the wavefilter coefficient per grid level. This error estimator is computationally efficient, and has shown similar accuracy to the Richardson approach on a variety of test problems. When <code>refine_criterion=3</code>, the original Lohner method is used.</p>
<p>A call to the user defined subroutine <em>usr_refine_grid</em> follows the error estimator, making it possible to use this routine for augmented user-controlled refinement, or even derefinement.</p>
<p>Depending on the error estimator used, it is needed or advisable to additionally provide a buffer zone of a certain number of grid cells in width, which will surround cells that are flagged for refinement by any other means. It will thus trigger more finer grids. <code>nbufferx^D=2</code> is usually sufficient. It can never be greater than the block size. For Lohner scheme, the buffer can actually be turned off completely by setting <code>nbufferx^D=0</code> which is default value.</p>
<h3><a class="anchor" id="par_flags"></a>
w_refine_weight, logflag, refine_threshold, derefine_ratio</h3>
<p>In all error estimators mentioned above (except the refine_criterion=1 case), the comparison or evaluation is done only with a user-selected (sub)set of the conserved variables. The <em>nw</em> variables (which may include auxiliary variables) can be used for error estimation, by setting corresponding weights in the array <em>w_refine_weight</em>, which by default has the first element (corresponds to density) as 1.d0 and rest elements as 0.d0. The weights w_refine_weight(:) must be positive values between 0.0d0 and 1.0d0, and must add to unity.</p>
<p>The Lohner error estimation (refine_criterion=3) may also decide to use differences in the log10(rho), and this is then done by setting the <em>logflag(1)=T</em>. This can be done per selected variables involved in the estimation, but obviously only works for those that remain positive throughout.</p>
<p>In the comparison involving the above selected variables, when the total error exceeds the value set by <code>refine_threshold</code>, the grid is triggered for refining. Reversely, if the error drops below <code>derefine_ratio * refine_threshold</code>, the grid is coarsened. The user must always set a (problem dependent) value for <code>refine_threshold</code> (below 1), while the default value for derefine_ratio=1.0d0/8.0d0 has shown to be a rather generally useful value. You can set threshold values that differ per refinement level.</p>
<p>When subroutine <em>usr_refine_threshold</em> is registered, user can use it to modify refine_threshold depending on location of interest. For example, increase refine_threshold near quiet boundaries to use coarser blocks there or decrease it to use finer blocks in focused regions.</p>
<h3><a class="anchor" id="par_iprob"></a>
iprob</h3>
<p>As a possible integer switch for selecting multiple problem setups in the same executable code, the integer switch <code>iprob</code> is provided. It is meant to be used only in the user-written subroutines, for switching between e.g. multiple initial conditions for the same executable.</p>
<h3><a class="anchor" id="par_prolongprim"></a>
prolongprimitive, coarsenprimitive</h3>
<p>It is possible to enforce the code to use primitive variables when coarsening grid information (coarsen), or filling new finer level grids (prolongation). They are then used instead of the conservative variables, which may not be a wise choice, but is perhaps better behaved with respect to positivity of pressure etc. This is activated seperately for prolongation by <code>prolongprimitive=T</code>, and for coarsen by <code>coarsenprimitive=T</code>.</p>
<p>The parameters <code>tfixgrid, itfixgrid</code> are available to fix the AMR hierarchical grid from a certain time onwards (tfixgrid) or iteration (the it- counter for the timesteps) onwards (itfixgrid). This may be handy for steady- state computations, or for those cases where you know that the initial conditions and physical setup is such that the AMR structure at t=0 will be optimal for all times.The parameter <code>ditregrid</code> is introduced to reconstruct the whole AMR grids once every ditregrid iteration(s) instead of regridding once in every iteration by default.</p>
<h3><a class="anchor" id="par_stretched"></a>
stretch_dim, stretch_uncentered, qstretch_baselevel, nstretchedblocks_baselevel</h3>
<p>We allow stretching of the grid, in combination with any coordinate system (cartesian/polar/cylindrical/spherical) you choose. You activate grid stretching by setting <code>stretch_dim(1:ndim)</code>, for example for the second dimension: </p><pre class="fragment">stretch_dim(2) = 'none' | 'uni' | 'symm'
</pre><ul>
<li>'none' means don't stretch this dimension, which is the default.</li>
<li>'uni' means unidirectional stretching, where the grid cells change by a constant factor from cell to cell. The factor for the lowest refinement level can be set by setting <code>qstretch_baselevel=1.01</code> (typical values are 1.01 to 1.05 or so, although any number larger than 1 is possible).</li>
<li>'symm' means symmetric stretching, which is e.g. useful for setting up periodic domain problems or so. You then specify how many blocks you want to have unstretched (uniform) in the middle. E.g., you may have set up 8 blocks along a dimension at level 1, and then you can ask nstretchedblocks_baselevel=2,4,6 or 8.</li>
</ul>
<p>Stretching can be useful for the radial coordinate in polar/spherical/cylindrical, or you can set the angle theta in 3D spherical to be stretched symmetrically, to leverage the CFL condition.</p>
<p>The parameter <code>stretch_uncentered</code> (default: true) controls whether <code><a class="el" href="mod__geometry_8t.html">mod_geometry.t</a></code> routines such as <code><a class="el" href="namespacemod__geometry.html#ae6552832949b076a9d4f2c96704077cc" title="Calculate divergence of a vector qvec within ixL.">divvector()</a></code> take into account that a cell face is not between stretched cell-centers. However, this is not yet taken into account in the reconstruction and symm/asymm boundary conditions, which may lead to issues, which can sometimes be avoided by setting <code>stretch_uncentered</code> to false.</p>
<h2><a class="anchor" id="par_paramlist"></a>
Paramlist</h2>
<pre class="fragment">&amp;paramlist
  dtpar= DOUBLE
  courantpar= DOUBLE
  typecourant= 'maxsum' | 'summax' | 'minimum'
  dtdiffpar= DOUBLE
  slowsteps= INTEGER
/
</pre> <h3><a class="anchor" id="par_dt"></a>
dtpar, courantpar, typecourant, dtdiffpar, dtTCpar, slowsteps</h3>
<p>If <code>dtpar</code> is positive, it sets the timestep <code>dt</code>, otherwise <code>courantpar</code> is used to limit the time step based on the Courant condition. The default is <code>dtpar=-1.</code> and <code>courantpar=0.8</code>.</p>
<p>For resistive MHD, the time step is also limited by the diffusion time: <code>dt &lt; dtdiffpar*dx^2/eta</code>. The default is <code>dtdiffpar=0.5</code>. Further restrictions on the time step can be put in the <em>usr_get_dt</em> subroutine in the mod_usr.t. The library routines for viscosity and div B diffusive cleaning, all use the coefficient <code>dtdiffpar</code> in their stability conditions. The &lsquo;typecourant='maxsum&rsquo;` means that the time step limit for the CFL conditions takes the maximum over a summed contribution to the maximum physical propagation speed for all dimensions. The detailed formulae are found in setdt.t.</p>
<p>If the <code>slowsteps</code> parameter is set to a positive integer value greater than 1, then in the first <code>slowsteps-1</code> time steps <code>dt</code> is further reduced according to the dt= dt * [ 1 - (1-step/slowsteps)**2 ] formula, where <code>step=1..slowsteps-1</code>. This reduction can help to avoid problems resulting from numerically unfavourable initial conditions, e.g. very sharp discontinuities. It is normally inactive with a default value -1.</p>
<h1><a class="anchor" id="par_pdpnamelists"></a>
Physics-dependent Namelists</h1>
<h2><a class="anchor" id="par_rholist"></a>
rho list</h2>
<pre class="fragment">&amp;rho_list
  rho_v= ndim doubles for advection velocity
/
</pre><h2><a class="anchor" id="par_nonlinearlist"></a>
nonlinear list</h2>
<pre class="fragment">&amp;nonlinear_list
  nonlinear_flux_type= INTEGER
  kdv_source_term= F | T
/
</pre> <h2><a class="anchor" id="par_hdlist"></a>
HD list</h2>
<pre class="fragment">&amp;hd_list
  hd_energy= T | F
  hd_n_tracer= INTEGER
  hd_gamma= DOUBLE 
  hd_adiab= DOUBLE
  hd_dust= F | T
  hd_thermal_conduction= F | T
  hd_radiative_cooling= F | T
  hd_gravity= F | T
  hd_viscosity= F | T
  hd_particles= F | T
  He_abundance= DOUBLE from 0 to 1
  SI_unit= F | T
/
</pre> <h2><a class="anchor" id="par_mhdlist"></a>
MHD list</h2>
<pre class="fragment">&amp;mhd_list
 mhd_energy= T | F
 mhd_n_tracer= INTEGER
 mhd_gamma= DOUBLE 
 mhd_adiab= DOUBLE
 mhd_eta= DOUBLE
 mhd_eta_hyper= DOUBLE
 mhd_etah= DOUBLE 
 mhd_glm_alpha= 0.5d0 between 0 and 1
 mhd_glm_extended= T | F
 mhd_magnetofriction= F | T
 mhd_thermal_conduction= F | T
 mhd_radiative_cooling= F | T
 mhd_Hall= F | T
 mhd_gravity= F | T
 mhd_viscosity= F | T
 mhd_particles= F | T
 mhd_4th_order= F | T
 mhd_internal_e= F | T
 mhd_hydrodynamic_e= F | T
 mhd_semirelativistic= F | T
 mhd_boris_simplification= F | T
 mhd_reduced_c = 6.d8
 mhd_trac= F | T
 mhd_trac_type= INTEGER from 1 to 6
 mhd_trac_mask= bigdouble
 mhd_trac_finegrid= INTEGER
 typedivbfix= 'linde'|'ct'|'glm'|'powel'|'lindejanhunen'|'lindepowel'|'lindeglm'|'multigrid'|'none'
 type_ct='uct_contact'|'uct_hll'|'average'
 source_split_divb= F | T
 boundary_divbfix= 2*ndim logicals, all false by default
 divbdiff= 0.8d0 between 0 and 2
 typedivbdiff= 'all' | 'ind'
 clean_initial_divb= F | T
 divbwave= T | F
 B0field= F | T
 B0field_forcefree= T | F
 Bdip= DOUBLE
 Bquad= DOUBLE
 Boct= DOUBLE
 Busr= DOUBLE
 He_abundance= DOUBLE from 0 to 1
 SI_unit= F | T
/
</pre> <h3><a class="anchor" id="par_divbfix"></a>
Magnetic field divergence fixes</h3>
<p>The upwind constrained transport methods <b>typedivbfix='ct'</b> by Gardiner and Stone in <em>Journal of Computational Physics, 205, 509-539 (2005)</em> <b>type_ct='uct_contact'</b> (default), or by Del Zanna, L., Zanotti, O., Bucciantini, N., &amp; Londrillo, P. in <em>Astronomy &amp; Astrophysics , 473, 11 (2007)</em> <b>type_ct='uct_hll'</b>, using staggered grid for magnetic field, can preserve initial div B to round off errors. A simple non-upwinding version of ct is through averaging electric fields from neighbors <b>type_ct='average'</b>. And it only works with HLL, HLLC, and HLLD schemes in the current implementation. It works in Cartesian and non-Cartesian coordinates with or without grid stretching. It works with finite non-zero resistivity. Initial conditions and boundary conditions for magnetic field have to be given at corresponding cell faces instead, or vector potential is given at corresponding cell edges, see examples: <b>tests/mhd/solar_atmosphere_2.5D</b>. Note that when using AMR, the div B preserving prolongation for CT requires even number of ghost cell layers and odd number of ghost layers for some slope limiters, e.g. mp5, is added by one to become even.</p>
<p>In cell-center based magnetic fields, sources proportionate to the numerical monopole errors can be added, in a source-split way, to momemtum, energy, and induction equation (the 'powel' type), or to the induction equation alone (the 'janhunen' type) for cleaning divB errors. The <code>divbwave</code> switch is effective for the Riemann type solvers for multi-D MHD only. The default true value corresponds to Powell divergence wave which stabilizes the Riemann solver.</p>
<p>Another source term strategy for monopole error control is choose 'linde' type to do parabolic cleaning, i.e. add source terms which diffuse the local error at the maximal rate still compliant with the CFL limit on the time step. This is activated when <code>divbdiff</code> is set to a positive number, which should be less than 2, and again comes in various flavors depending on which equations receive source terms. The choice where only the induction equation gets modified, i.e. &lsquo;typedivbdiff='ind&rsquo;` can be used.</p>
<p>GLM-MHD mixed hyperbolic and parabolic dampening of the divB error using an additional scalar variable <code>Psi</code>. The algorithm of 'glm' is described by Dedner et al. as <em>Equation (24)</em> in <em>Journal of Computational Physics 175, 645-673 (2002) doi:10.1006/jcph.2001.6961</em>. The default one with parameter <b>mhd_glm_extended=.true.</b> is the extended GLM-MHD with divb related sources terms in momemtum and energy equation. The GLM-MHD method without the sources terms is used when <code>mhd_glm_extended=.false.</code>. The parameter <code>mhd_glm_alpha</code> ranging from 0 to 1.0 is the ratio of the diffusive to advective time scales for divb cleaning. You can choose 'lindejanhunen', 'lindepowel', or 'lindeglm' to use combined divb cleaning.</p>
<p>Projection scheme using multigrid Poisson solver by Teunissen and Keppens in <em>Computer Physics Communications 245, 1068, (2019)</em> can be chosen as 'multigrid' to remove div B part of B. If <code>clean_initial_divb</code> is set to T, the projection scheme is used to remove div B once after initial condition in unstretched Cartesian CT-MHD cases.</p>
<h3><a class="anchor" id="par_MFS"></a>
Magnetic field splitting strategy</h3>
<p>For MHD, we implemented the possibility to use a splitting strategy following Tanaka, where a time-invariant background magnetic field is handled exactly, so that one solves for perturbed magnetic field components instead. This method works with HLLD, HLL and TVDLF flux and with all divb cleaning methods. The magnetic field splitting is activated by <code>B0field=T</code>, and the magnitude of the background magnetic field can be controlled using the parameters <code>Bdip, Bquad, Boct, Busr</code>. The first three are pre-implemented formulae for a dipole, quadrupole and octupole field in spherical coordinates only (the parameters set the strength of the dipole, quadrupole and octupole field). This is coded up in the module <em>set_B0.t</em>. This same module calls in addition the <em>usr_set_B0</em> subroutine when <code>Busr</code> is non-zero, where it then should be used to quantify an additional time-independent field. This latter can be used for cartesian or cylindrical coordinates as well. User can possibly prescibe analytic current in <em>usr_set_J0</em> subroutine to significantly increase accuracy. Choose <code>B0field_forcefree=T</code> when your background magnetic field is forcefree for better efficiency and accuracy.</p>
<h3><a class="anchor" id="par_TRAC"></a>
The transition region adaptive conduction (TRAC) method</h3>
<p>For solar atmosphere, simulations can sometimes suffer from the huge temperature gradient in the transition region. If the resolution is not enough (typically 1 km), the upward evaporation might be underestimated. The TRAC method could be used to correct the evaporation through artificially broadening the transition region. Set 'mhd_trac=T' to enable this function. 'mhd_trac_type=1' is the basic TRAC method for 1D simulation (see Johnston et al. 2019, 2020). When it is used for 2D or 3D simulations, the local cutoff temperature inside each block would be calculated separately. It is the fastest way in multi-D simulations, it is not accurate but basically, is physically correct. For multi-D uniform Cartesian grids, we prepared some other methods. 'mhd_trac_type=3' is the multi-D TRAC method based on the field line tracing module. For multi-D simulations, it should be the most accurate one, but might be very slow. Considering that this TRAC modificaiton will mostly affect the transition region, one can use 'mhd_trac_type=5' to add a mask to limit the region where the field lines are integrated. Give 'mhd_trac_mask' to set the maximum height of the mask, in your unit_length. 'mhd_trac_type=4' uses the block-based TRAC method for multi-D simulations, which should be faster than the second type. And 'mhd_trac_type=6' works in a similar way with the 4th type, by adding a mask on the block-based TRAC method. Give 'mhd_trac_finegrid' to set the distance between two adjacent traced field lines (in the unit of finest cell size). Note that when setting 'mhd_trac_type &gt;=3', the direction of your gravity should follow y-dir (2D) or z-dir(3D).</p>
<p>'mhd_trac_type=2' is anthor TRAC method, which broadens the transition region according to a different criterion. Unlike Johnston TRAC method, this TRAC method has the advantage that all the calculation is done locally within the block. Thus, it could be used in either 1D (M)HD or multi-D MHD simulations, and is much faster than other multi-D methods.</p>
<h3><a class="anchor" id="par_AIE"></a>
Solve internal or hydrodynamic energy to avoid negative pressure</h3>
<p>In extremely low beta plasma, internal energy or gas pressure easily goes to negative values when solving total energy equation, because numerical error of magnetic energy is comparable to the internal energy due to its extremely small fraction in the total energy. We have two methods to avoid this problem. In the first method, we solve internal energy equation instead of total energy equation by setting <code>mhd_internal_e=T</code>. This function is compatible with all finite volume and finite difference schemes we have, including HLL, HLLC, and HLLD, in which the Riemann flux of the internal energy is evaluted as the HLL flux in all intermediate states of the Riemann fan. In the second method, We solve hydrodynamic energy, i.e., internal and kinetic energy, instead of total energy with an additional source term of Lorentz force work, by setting <code>mhd_hydrodynamic_e=T</code>, which has better conservation than solving internal energy.</p>
<h3><a class="anchor" id="par_semirelati"></a>
Solve semirelativistic MHD to tackle extreme Alfven speed</h3>
<p>The Alfven speed in nonrelativistic MHD, defined as B/sqrt(mu rho), can be extremely large, even unphysically larger than speed of light in strong magnetic field and low density regions. Semirelativistic MHD equations (Gombosi et al. 2002 JCP 177, 176) as the nonrelativistic hydrodynamic limit of the relativistic MHD equations solve the problem and have the same steady-state solution as nonrelativistic MHD. By artificially lowering the speed of light, one can reduce the wave speeds allowing larger time steps thus faster solution in explicit numerical schemes. Set 'mhd_semirelativistic=T' and 'mhd_reduced_c' equals to a value smaller than light speed with physical unit to solve semirelativistic MHD. If setting 'mhd_hydrodynamic_e=T' or 'mhd_internal_e=T', the approximate split semirelativistic MHD equations (Rempel 2017 ApJ 834, 10) are solved with hydrodynamic or internal energy instead of total energy. Boris simplification of semirelativistic MHD equations can be solved by setting 'mhd_boris_simplification=T' and 'mhd_semirelativistic=F' to get faster but less accurate solutions. 'mhd_boris_simplification=T' is working with all versions of MHD equations including 'mhd_internal_e=T' and 'mhd_hydrodynamic_e=T'. Since semirelativistic MHD waves are very complicated, only approximate fast magnetosonic wave speed is implemented to use HLL or tvdlf scheme, schemes (such as HLLC and HLLD) depending on more wave speeds are not yet fully compatible with semirelativistic MHD. Note that when using semirelativistic MHD, the definitions of momentum and total energy are different from MHD, so call 'mhd_to_primitive' to get velocity and gas pressure from momentum and total energy instead of using the classic relations.</p>
<h2><a class="anchor" id="par_emissionlist"></a>
Synthetic EUV/SXR/whitelight emission</h2>
<p>User can synthesize EUV images, EUV spectra, SXR images and whitelight images using 3D .dat files inside amrvac. These can be finished easily by adding some parameters into .par file. The images/spectra will be output to .vtu/.vti files when the convert_type in <a class="el" href="md_doc_par.html#par_filelist">Filelist</a> is set to 'EIvtiCCmpi', 'ESvtiCCmpi', 'SIvtiCCmpi' ... Thehe size of a pixel is the same as that in relevant observation data (such as SDO and RHESSI). The point spread function (PSF, instrument effect) has been included for 'instrument' resolution.</p>
<p>The line of sight (LOS) is controlled with 'LOS_theta' and 'LOS_phi', where the LOS is anti-parallel to the vector [cos(LOS_phi)*sin(LOS_theta), sin(LOS_phi)*sin(LOS_theta),cos(LOS_theta)] (see the following figure). The units of 'LOS_theta' and 'LOS_phi' are degree. User can rotate the image with 'image_rotate' (in degree). In cartesian coordinate, the y direction of the image is located in a plane given by the LOS and the z direction of the simulation data. In spherical coordinate, the definations of 'LOS_theta' and 'LOS_phi' are the same with theta and phi of the coodinate, but 'LOS_theta' and 'LOS_phi' are in degree.</p>
<p>The whitelight emission supposed observed by LASCO can be synthesized, and the instrument related parameter refers to 'whitelight_instrument'. User can specify the radius of the occultor of the instrument with 'R_occultor' (in solar radius).</p>
<p><img src="LOS_emission.png" alt="" class="inline"/></p>
<p>The wavelength of an EUV image is defined with 'wavelength'. The bottom/upper cutoff energy of SXR image is defined with 'emin_sxr'/'emax_sxr' (in keV).</p>
<p>The wavelength of the EUV spectra is defined with 'spectrum_wl'. When 'spectrum_euv' is 'true', spectra at a slit in the corresponding image will be given. The output is a 2D image, where x-axis is wavelength and y-axis is space (physics distance at the slit). The slit is parallel to the y axis of corresponding EUV image (controlled by 'LOS_theta', 'LOS_phi' and 'image_rotate'). The location of the slit 'location_slit' is the x value of the image. The location of the slit 'location_slit' is the coordinate value at the third direction (perpendicular to LOS and slit). For example, the LOS along x direction and the slit along y direction, then 'location_slit' should be z of the slit. The domain in wavelength is controlled by 'spectrum_window_min' and 'spectrum_window_max'.</p>
<p>In cartesian, the mapping between simulation box coordinate and synthesized image coordinate is not only controlled by LOS, but also controlled by the parameter 'x_origin'. The simulation box point given by 'x_origin' will always located at (X=0,Y=0) of the synthesized image. The parameter 'big_image' is added for making movie that the LOS is changing. When 'big_image=T', then the synthesized EUV/SXR image will have a fixed big domain. The domain will not change when changing the LOS, and the whole simulation box will always be convered inside the domain. The parameter 'x_origin' is also added for making such kind of movie.</p>
<p>Two types of resolution are supported: data resolution and instrument resolution. In data resolution, the size of the image pixel is the same as the size of the finest cell. In instrument resolution, the size of a pixel is the same as that in relevant observation data (such as SDO and RHESSI). The point spread function (PSF, instrument effect) has been included for instrument resolution. The spatial resolution or EUV image/SXR image/EUV spectra is controlled by the parameter 'dat_resolution'. The default resolution is instrument resolution, and the data resolution can be activated by setting 'dat_resolution' to 'True'. Under the instrument resolution, the spatial resolution can be artificially changed with the parameter 'instrument_resolution_factor'. For example, we can double the spatial resolution by setting 'instrument_resolution_factor=2'.</p>
<p>The default unit of length for the outputed image is arcsec and the related variables in .par file, but user can set 'activate_unit_arcsec' to F to use the simulation length unit.</p>
<p>Only Cartesian and spherical coordinate system are supported currently. In spherical coordinate, region below 'R_opt_thick' (in solar radius, default value is 1) is assumed as not transparent. </p><pre class="fragment">&amp;emissionlist
  filename_euv= CHARACTER
  wavelength= 94 | 131 | 171 | 193 | 211 | 304 | 335 | 1354 | 263 | 264 | 192 | 255
  LOS_theta= DOUBLE
  LOS_phi= DOUBLE
  image_rotate= DOUBLE
  x_origin(1:3)= DOUBLE
  big_image= LOGICAL
  filename_sxr= CHARACTER
  emin_sxr= INTEGER
  emax_sxr= INTEGER
  filename_spectrum= CHARACTER
  spectrum_wl= 1354 | 263 | 264| 192 | 255
  spectrum_window_min= DOUBLE
  spectrum_window_max= DOUBLE
  location_slit= DOUBLE
  filename_whitelight= CHARACTER
  whitelight_instrument= 'LASCO/C1' | 'LASCO/C2' | 'LASCO/C3'
  R_occultor= DOUBLE
  R_opt_thick= DOUBLE
  activate_unit_arcsec= LOGICAL
  dat_resolution=LOGICAL
  instrument_resolution_factor=INTEGER
/
</pre><h2>Splitting of the hydrostatic equilibrium</h2>
<p>set </p><div class="fragment"><div class="line">has_equi_pe0 = .true.</div>
<div class="line">has_equi_rho0 = .true.</div>
</div><!-- fragment --><p> to true in <em><b>mhd_list</b></em> and implement usr_set_equi_vars in mod_ust.t file</p>
<div class="fragment"><div class="line">subroutine usr_init()</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">  usr_set_equi_vars =&gt; special_set_equi_vars</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line">end subroutine usr_init</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">subroutine special_set_equi_vars(ixI^L,ixO^L,x,w0)</div>
<div class="line">  use mod_global_parameters</div>
<div class="line">  integer, intent(in)             :: ixI^L,ixO^L</div>
<div class="line">  double precision, intent(in)    :: x(ixI^S,1:ndim)</div>
<div class="line">  double precision, intent(inout) :: w0(ixI^S,1:number_equi_vars)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  w0(ixO^S,equi_pe0_) = ...</div>
<div class="line">  w0(ixO^S,equi_rho0_) = ...</div>
<div class="line"> </div>
<div class="line">end subroutine special_set_equi_vars</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
