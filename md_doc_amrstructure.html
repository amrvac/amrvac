<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MPI-AMRVAC: Adaptive Mesh Refinement</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="my_customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MPI-AMRVAC
   &#160;<span id="projectnumber">3.0</span>
   </div>
   <div id="projectbrief">The MPI - Adaptive Mesh Refinement - Versatile Advection Code</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Adaptive Mesh Refinement </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Introduction</h1>
<p>This document briefly describes the AMR-related features in MPI-AMRVAC. The different options can be set in the meshlist part (see <a class="el" href="md_doc_par.html">Setting parameters</a>) of the <b>amrvac.par</b> file. For a more extensive description, you can read the article 'Parallel, grid-adaptive approaches for relativistic hydro and magnetohydrodynamics', R. Keppens, Z. Meliani, A.J. van Marle, P. Delmont, A. Vlasis, &amp; B. van der Holst, 2011, JCP.* <a href="http://dx.doi.org/10.1016/j.jcp.2011.01.020">doi:10.1016/j.jcp.2011.01.020</a>.</p>
<p>MPI-AMRVAC uses a standard block-based, octree AMR scheme, where we have blocks of user-controlled dimension (set by the block_nx1, block_nx2, block_nx3) in a hierarchically nested manner. To simplify the parallelization, we gave up flexibility to allow different sized refinement ratios between grid levels, fixing it to 2. Also, we now use the same time step for all levels. A generic skeleton code, generic enough to hold for any AMR code having similar restrictions, is shown below.</p>
<p><img src="skeleton.gif" alt="" class="inline"/></p>
<p>Some more info follows on the different aspects involved.</p>
<h1>Important (global) parameters</h1>
<p>Some important global parameters are in the module <em><a class="el" href="mod__global__parameters_8t.html">mod_global_parameters.t</a></em>. In particular, note that the maximum number of blocks per processor is the parameter <b>max_blocks</b>, and the maximum number of levels is the parameter <b>nlevelshi</b>. The latter is default set to 20. If your want to run with more levels, and/or allow for more grids per processor, you need to change their value and recompile. The number of levels set in the par file as <em>refine_max_level</em> must always be smaller or equal to <b>nlevelshi</b>. This <b>nlevelshi</b> also returns in those parameters that are defined per level, such as <em>limiter</em> which needs to be set for all (default) 20 levels.</p>
<h1>AMR criteria</h1>
<p>This in essence describes the module <em><a class="el" href="errest_8t.html">errest.t</a></em>, or at least its most essential aspets.</p>
<p>The block-tree nature implies that a decision for refining/coarsening is to be made on a block-by-block basis. This automated block-based regridding procedure involves 3 steps: </p><pre class="fragment">(1) consider all blocks at level 1&lt; l&lt; _refine_max_level_ , with _refine_max_level_ the maximal grid level selected;
(2) quantify the local error E_\xx at each gridpoint in a certain grid block;
(3) if any point has this error exceeding a user-set threshold _refine_threshold(l)_, refine this block (and ensure proper nesting);
(4) if all points have their error below a user-set fraction of the threshold _derefine_ratio(l)_ used in the previous step, coarsen the block (for l&gt;1).
</pre><p> The local error estimator can be one of four options, selected by <em>refine_criterion</em>, each possibly augmented with user-defined criteria. For <em>refine_criterion=0</em>, only refinement based on <em>usr_refine_grid</em> is active. Any of the other 3 estimators use a user-selected subset of the conserved or auxiliary variables (or even variables that are computed dynamically at the time of regridding), through the formula <img src="error1.gif" alt="" class="inline"/></p>
<p>The indices included are user-identified with the <em>w_refine_weight</em> array, where the sum of weights of all variables should equal to 1. The estimated error is a weighted sum of contributions from all variables with non-zero weight.</p>
<p>For <em>refine_criterion=1</em>, a local comparison merely employs the availability of the t^{n-1} and t^n solution vectors. It estimates the local relative variable errors as <img src="error3.gif" alt="" class="inline"/></p>
<p>This is obviously computationally cheaper, but has the disadvantage that it in essence uses historical info, which may be insufficient for rapidly moving, strong shock cases. In our experience, local error estimators work satisfactorily on a variety of test problems, but may need an added, user-set buffer zone around each grid point flagged for refinement in this manner. This zone sets the buffer width in numbers of grid cells (per dimension) <em>nbufferx1,...</em> about flagged grid cells.</p>
<p>For <em>refine_criterion=2</em> or <em>refine_criterion=3</em>, we select a Lohner type [R. Lohner, An adaptive finite element scheme for transient problems in CFD, Comp. Meth. App. Mech. Eng. 61, 323 (1987)] prescription as also used in the PARAMESH library or the FLASH3 code. In our experience, it does not require any of the buffering just discussed, and is computationally efficient as it employs only instantaneous values from t^n. It in essence discretizes a weighted second derivative in each grid point.</p>
<p>The <em>refine_criterion=3</em> is also Lohner prescription, which writes in formulae as <img src="error4.gif" alt="" class="inline"/></p>
<p>where the operators mean a central difference and a sum, per dimension. The wave filter parameter is set per level, and defaults as <em>amr_wavefilter(1:nlevelshi)=1.0d-2</em>.</p>
<h1>Data structures</h1>
<p>The data structures are defined in <em><a class="el" href="mod__physicaldata_8t.html">mod_physicaldata.t</a></em> and <em><a class="el" href="mod__forest_8t.html">mod_forest.t</a></em>, you can inspect them for learning more details.</p>
<p>We provide details on useful data structures. All of these are suited for any curvilinear coordinate system, and merely reflect the tree structure of the block-AMR. We implicitly assume a fixed refinement ratio of two. Schematic figures for a 2D Cartesian case generalize straightforwardly to higher or lower dimensionality.</p>
<p>The overall domain is considered 'rectangular', i.e. bounded by coordinate pairs <em>xprobmin1,xprobmax1, ...</em> in each dimension. On the lowest grid level l=1, one controls the coarsest resolution as well as a suitable domain decomposition, by specifying both the total number of level 1 grid cells <em>domain_nx1, ...</em> along with the individual block size per dimension <em>block_nx1, ...</em>, which exclude the ghost cells. The total cell number must be an integer multiple of the block size, so e.g., domain_nx1=4 block_nx1.</p>
<p>A hypothetical 2D domain is shown below, which corresponds to a domain where 4 by 3 blocks on level 1 are exploited in this domain decomposition, and where local refinement was activated in 4 out of these level l=1 blocks, here in the top right domain corner, as well as in one level l=2 grid. <img src="dataAA.gif" alt="" class="inline"/> Global, integer grid indices are introduced per dimension, in a manner where knowledge of these grid indices, combined with AMR level knowledge, instantly allows one to localize the grid when needed. Following the figure, the grid on level l=2 indicated by global grid indices (5,3) is indeed the fifth grid block horizontally, and the third vertically, when the domain would be resolved fully with level l=2 blocks. The total amount of grid blocks per dimension, per level l, is stored in <em>ng^D(l)</em>, and the actual length of a grid block on level l, per dimension, is <em>dg^D(l)</em>.</p>
<p>The bottom figure reflects the tree representation of the same hypothetical grid hierarchy, where the presence of a grid leaf at a certain grid level is identified through a boolean variable. As indicated before, the total number of active grid leafs <em>nleafs</em> may change from timestep to timestep. This tree info is stored in the structure <em>tree_root(ig^D(l))</em>, which knows about the global grid index through <em>tree_root(ig^D(l))nodeig^D</em>, the level <em>tree_root(ig^D(l))nodelevel</em>, the processor on which it resides through the integer <em>tree_root(ig^D(l))nodeipe</em>, and its presence or absence in the logical <em>tree_root(ig^D(l))nodeleaf</em>. <img src="dataAB.gif" alt="" class="inline"/></p>
<p>Various extra indices are helpful to traverse the tree structure. Local grid indices across AMR levels are schematically given below, which are used to identify the directional neighbours, as well as the children and parent blocks. These are used to realize and facilitate the possible interprocessor communication patterns, which are schematically shown at right.</p>
<p><img src="dataA.gif" alt="" class="inline"/></p>
<p><img src="dataB.gif" alt="" class="inline"/></p>
<p><img src="dataD.gif" alt="" class="inline"/></p>
<p><img src="dataG.gif" alt="" class="inline"/></p>
<p>The directional neighbours of a grid block are shown for a 1D, 2D and 3D case in the picture below. <img src="dataC.gif" alt="" class="inline"/></p>
<p>For parallelization, we adopted a fairly straightforward Z-order or Morton- order space filling curve (SFC). For the same hypothetical grid structure shown previously, the Morton space-filling curve is illustrated below, along with the resulting distribution of these 27 grid blocks on 4 CPUs. Load-balancing is done after every timestep, following the adaptive remeshing. When exploiting N_p CPUs, our strategy for load balancing merely ensures that each CPU has at least [nleafs/N_p]_int (denoting integer division) grid blocks, while the remainder increase this number by 1 for the first as many CPUs. In the example shown, this implies that the first 3 CPUs each contain 7 grid blocks, while the fourth has 6. The grid Morton numbers of all grids residing on processor <em>mype</em> lie between <em>Morton_start(mype),Morton_stop(mype)</em>. The global grid index, once you know the grid Morton number <em>Morton_no</em> is found from <em>sfc_to_igrid(Morton_no)</em>, which gives the relation between the SFC and the global grid index <em>igrid</em>. The data for the conservative variables for grid <em>igrid</em> is then actually found from <em>pw(igrid)w</em>. <img src="dataF.gif" alt="" class="inline"/></p>
<p>Some operations benefit from having a linear, linked list possibility to traverse the tree on a level by level basis. To that end, each grid also contains a pointer to the previous and next grid created in the same AMR level, taking all grids on all processors into account. This linked list is complemented with a globally known pointer to the first (head) and last (tail) grid on each level. For the hypothetical grid structure used above, this corresponding linked list representation is shown next. <img src="dataE.gif" alt="" class="inline"/> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
