<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MPI-AMRVAC: Reading the dat files</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="my_customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MPI-AMRVAC<span id="projectnumber">&#160;3.1</span>
   </div>
   <div id="projectbrief">The MPI - Adaptive Mesh Refinement - Versatile Advection Code</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Reading the dat files</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="introductiondat"></a>
Introduction on reading datfiles</h1>
<p>This page provides guidelines and examples to read in and process MPI-AMRVAC <code>.dat</code> files with Python. All required packages and instructions on how to set up the tools folder are described in <a class="el" href="md_doc_2python__setup.html">Setting up the python tools</a>. The datfile tools can be found in the folder <code>$AMRVAC_DIR/tools/python/datfiles</code>.</p>
<blockquote class="doxtable">
<p>&zwj;<b>Please note</b>: the legacy Python tools do <em>not</em> support polar/cylindrical/spherical datasets, and/or stretched/staggered grids. We (highly) recommend to use <code>yt</code> (<a class="el" href="md_doc_2yt__usage.html">see the docs</a>) for datfile analysis with Python. </p>
</blockquote>
<h1><a class="anchor" id="reading_dat"></a>
Reading datasets</h1>
<h2>Obtaining dataset information</h2>
<p>All functionality is contained in the file <code>amrvac_reader.py</code>, present in the <code>datfiles/reading</code> subdirectory. This class contains various instances and methods linking to other classes and methods in different subdirectories, keeping usage plain and simple with just one single import. To import the reader into your script (assuming you installed <code>amrvac_pytools</code>): </p><pre class="fragment">import amrvac_pytools as apt
</pre><p> As an example, we will use the file <code>KH0015.dat</code>, which is the 2D MHD Cartesian Kelvin-Helmholtz problem from the tests folder. In order to read in this file, it is sufficient to type </p><pre class="fragment">ds = apt.load_datfile('KH0015.dat')
</pre><p> It is necessary to stress that this command loads the <b>information</b> of the <code>.dat</code> file, <b>not</b> the actual data itself. This is especially useful to inspect large datasets or time series, without having to load the data into memory every time. We can inspect this dataset further by using <code>ds.get_info()</code>, which prints </p><pre class="fragment">[INFO] Current file      : KH0015.dat
[INFO] Datfile version   : 4
[INFO] Current time      : 7.5
[INFO] Physics type      : mhd
[INFO] Boundaries        : [0. 0.] -&gt; [4. 4.]
[INFO] Max AMR level     : 3
[INFO] Block size        : [12 12]
[INFO] Number of blocks  : 172
----------------------------------------
Known variables: ['rho', 'm1', 'm2', 'e', 'b1', 'b2', 'v1', 'v2', 'p', 'T']
</pre><p> Note that both the conserved and primitive variables are known and available for data analysis. The current time of the dataset can be retrieved by <code>ds.get_time()</code>, the physical boundaries can be obtained by <code>ds.get_bounds()</code>. The latter returns a list in the form <code>[[x1, x2], [y1, y2]]</code>, which will be extended by <code>x3, y3 and [z1, z2, z3]</code> for a 3D dataset, with similar reasoning for a 1D dataset. The method <code>ds.get_extrema(var)</code> returns the minimum and maximum value of the required variable <code>var</code> in the entire dataset, where <code>var</code> is one of the known variables above.</p>
<h2>Working with the data</h2>
<p>In order to load the entire dataset into memory, one can use the method </p><pre class="fragment">ad = ds.load_all_data()
</pre><p> Most likely the dataset will contain multiple levels of AMR, such that loading this into one single Numpy array is not trivial. Instead, a regridding is performed to the finest block level over the grid, and all blocks are regridded to this level using flat interpolation. This operation is parallelised using Pythons <code>multiprocessing</code> module, and will only work in Python 3. The optional argument <code>nbprocs</code> specifies the number of processors to use when performing the regridding, this will default to two less than the number available. The optional argument <code>regriddir</code> specifies the directory where to save the regridded data as <code>.npy</code> (Numpy) files. The default directory is <code>regridded_files</code>, which will be created in the same folder as the current script if it is not present. Subsequently, the reader will load this regridded data if the script is executed again.</p>
<p>The data can then be accessed by calling the corresponding name in the <code>ad</code> dictionary, for example: </p><pre class="fragment">rho = ad['rho']
</pre><p> or any other of the known variables (see above). This works in 1D, 2D and 3D, however, for large 3D datasets the regridding can take quite some time.</p>
<h1><a class="anchor" id="plotting_dat"></a>
Plotting datasets</h1>
<p>The datfile tools include support for plotting both 1D and 2D datasets, in two variants. The first option is directly plotting the regridded data, which requires that <code>ds.load_all_data()</code> has been called. Plotting is then done via </p><pre class="fragment">ds.rgplot(ad['rho'])
</pre><p> where we passed the Numpy array containing the density as an example.</p>
<p>The second option is much more convenient, as it supports plotting the AMR data directly with an optional mesh overlay. This is done through </p><pre class="fragment">ds.amrplot('rho')
</pre><p> Note the difference here between <code>rgplot</code> and <code>amrplot</code>, in calling the latter method we simply supply the name of the variable to plot. Finally, calling <code>ds.show()</code> shows all created figures in separate windows.</p>
<h2>Example</h2>
<p>The following code snippet produces the figure shown below. </p><pre class="fragment">ds = apt.load_datfile('KH0015.dat')
p = ds.amrplot('rho', draw_mesh=True, mesh_linewidth=0.5, mesh_color='white',
               mesh_linestyle='solid', mesh_opacity=0.8)
p.ax.set_title("Density plot")
p.fig.tight_layout()
ds.show()
</pre><p> When assigning the plot to the variable <code>p</code>, we can retrieve the matplotlib figure and axis instances by calling <code>p.fig</code> and <code>p.ax</code>, respectively, transferring full control of the figure to the user. The colorbar can be retrieved by <code>p.colorbar</code>. Plotting on a logarithmic scale is supported for both <code>rgplot</code> and <code>amrplot</code>, by supplying the argument <code>logscale=True</code>. As shown below, setting <code>draw_mesh=True</code> plots the overlaying AMR mesh. The linewidth, color, linestyle and opacity of the mesh are also specified, and can take in default <code>matplotlib</code> values. The colormap can be chosen by supplying the <code>cmap</code> argument, the default is <code>jet</code>.</p>
<div class="image">
<img src="example_py_datreader.png" alt=""/>
</div>
    <p>Both <code>rgplot</code> and <code>amrplot</code> create new <code>matplotlib</code> figure and axis instances that are used for plotting. However, both methods accept a figure and axis instance as extra argument, which will then be used instead. This is useful in for example plotting multiple snapshots on a single figure using subplots, like the example below shows. </p><pre class="fragment">import matplotlib.pyplot as plt

fig, ax = plt.subplots(1, 2, figsize=(10, 6))

ad = ds.load_all_data()
p1 = ds.amrplot('rho', fig=fig, ax=ax[0], draw_mesh=True, mesh_color='white', 
                 mesh_opacity=0.4, mesh_linewidth=1)
p2 = ds.rgplot(ad['p'], fig=fig, ax=ax[1], cmap='Greens')

p1.colorbar.set_label("density")
p2.colorbar.set_label("pressure")
p1.ax.set_title("density plot with mesh overlay")
p2.ax.set_title("pressure plot")

fig.tight_layout()
plt.show()
</pre> <h1><a class="anchor" id="synthetic_dat"></a>
Synthetic views</h1>
<p>The python tools also include a ray-tracing algorithm along one of the coordinate axes to create synthetic views. Currently two types are supported, the first one being a synthetic H-alpha view based on a method described in <a href="https://www.aanda.org/articles/aa/pdf/2015/07/aa25716-15.pdf" title="Paper">Heinzel et al. (2015)</a>. Basically, based on tables given in said paper the degree of ionisation is calculated using the local pressure and temperatures, from which the opacity can be calculated and eventually the H-alpha intensity by integrating along the line of sight. The second type is a synthetic view of the Faraday rotation measure, which is only possible for MHD datasets as it uses the component of the magnetic field parallel to the line of sight. Creating these views can be done as follows: </p><pre class="fragment">ds.halpha(line_of_sight='x')
ds.faraday(line_of_sight='x')
</pre><p> In this example, the line of sight is taken along the <code>x</code>-axis, which is the default value. The colormap can be specified using the <code>cmap</code> keyword argument, plotting on a logarithmic scale is done by supplying <code>logscale=True</code>. Additionally, just like before, the matplotlib figure, axis and colorbar instances can be obtained by calling for example <code>Ha = ds.halpha()</code>, followed by <code>Ha.fig</code>, <code>Ha.ax</code> or <code>Ha.colorbar</code>.</p>
<p>Please note that the creation of these synthetic views can take some time for large 3D datasets with multiple levels of AMR, as the routines have to integrate each block and merge the results into one single image. As a final comment, it is <b>important</b> that the units are correctly specified to ensure a consistent calculation of the synthetic views, see <a class="el" href="md_doc_2python__datfiles.html#dat_units">Units</a> below.</p>
<h1><a class="anchor" id="dat_units"></a>
Units</h1>
<p>Everything described above (except for the synthetic views) is calculated using <em>normalised code units</em>. In order to retrieve the correct physical values of the variables in the dataset, it is important (and good practice) to correctly define the unit normalisations. The default unit system is <code>cgs</code>, which can be switched to <code>si</code> via <br  />
 </p><pre class="fragment">ds.units.cgs=False
</pre><p> If <code>cgs</code> units are required, this can be omitted. Setting the normalisations is quite straightforward, and is done through </p><pre class="fragment">ds.units.set_units(unit_length=1.0e9, unit_numberdensity=1.0e9, unit_temperature=1.0e6)
</pre><p> using for example typical solar values in cgs. The <code>unit_length</code> and <code>unit_numberdensity</code> must always be specified, the third argument can either be <code>unit_temperature</code> or <code>unit_velocity</code>. The code then automagically calculates all other normalisations, which can be accessed through </p><pre class="fragment">ds.units.unit_length
ds.units.unit_numberdensity
ds.units.unit_temperature
ds.units.unit_density
ds.units.unit_magneticfield
ds.units.unit_time
</pre><p> and so on. Some astrophysical constants are also included, accessible in a similar manner by doing <code>ds.units.m_p</code>, which retrieves the proton mass in either cgs or si units, depending on the unit system used. Known constants are <code>R</code>, <code>m_e</code>, <code>m_p</code>, <code>k_B</code>, <code>ec</code>, <code>c</code> and <code>Rsun</code> for the gas constant, electron and proton mass, Boltzmann constant, electric charge, speed of light and solar radius, respectively. Converting a variable back to physical units can then be done using </p><pre class="fragment">pressure = ad['p'] * ds.units.unit_pressure
current_time = ds.get_time() * ds.units.unit_time
</pre><p> and so on. If no unit normalisations are specified, the default values of MPI-AMRVAC will be used. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
