!> module radiative cooling -- add optically thin radiative cooling for HD and MHD
!>
!> Assumptions: full ionize plasma dominated by H and He, ionization equilibrium 
!> Formula: Q=-n_H*n_e*f(T), positive f(T) function is pre-computed and tabulated or a piecewise power law
!> Developed by Allard Jan van Marle, Rony Keppens, and Chun Xia
!> Cooling tables extend to 1O^9 K, (17.11.2009)  AJvM
!> Included table by Smith (18.11.2009)           AJvM
!> Included luminosity output option (18.11.2009) AJvM
!> Included two cooling curves from Cloudy code supplied by Wang Ye (12.11.2011) AJvM
!> Included a solar coronal cooling curve (JCcorona) supplied by J. Colgan (2008) ApJ
!> Modulized and simplified by Chun Xia (2017)
!> Included piecewise power law functionality by Joris Hermans (01.2020)

module mod_radiative_cooling

! For the interpolatable tables: these tables contain log_10 temperature values and corresponding
! log_10 luminosity values. The simulation-dependent temperature and luminosity
! scaling parameters are supposed to be provided in the user file. 
! All tables have been extended to at least T=10^9 K using a pure Bremsstrahlung 
! relationship of Lambda~sqrt(T). This to ensure that a purely explicit calculation 
! without timestep check is only used for extremely high temperatures. 
! (Except for the SPEX curve, which is more complicated and therefore simply stops  
! at the official upper limit of log(T) = 8.16)

  use mod_global_parameters, only: std_len
  use mod_physics
  implicit none
  ! parameters used for implicit cooling source calculations
  
  !> Coefficent of cooling time step
  double precision, private   :: cfrac

  !> Lower limit of temperature
  double precision, private   :: tlow

  !> Helium abundance over Hydrogen
  double precision, private    :: He_abundance

  !> Resolution of temperature in interpolated tables
  integer, private :: ncool

  !> Name of cooling curve
  character(len=std_len), private  :: coolcurve

  !> Name of cooling method
  character(len=std_len), private  :: coolmethod

  !> Fixed temperature not lower than tlow
  logical, private    :: Tfix

  !> Add cooling source in a split way (.true.) or un-split way (.false.)
  logical :: rc_split=.false.

  !> Index of the density (in the w array)
  integer, private, parameter              :: rho_ = 1

  !> Indices of the momentum density
  integer, allocatable, private, protected :: mom(:)

  !> Index of the energy density
  integer, private, protected              :: e_
  !> Index of the internal energy density
  integer, private, protected              :: eaux_

  !> The adiabatic index
  double precision, private :: rc_gamma

  double precision, allocatable :: tcool(:), Lcool(:), dLdtcool(:)
  double precision, allocatable :: Yc(:), invYc(:)
  double precision  :: tref, lref, tcoolmin,tcoolmax
  double precision  :: lgtcoolmin, lgtcoolmax, lgstep
  
  ! The piecewise powerlaw (PPL) tabels and variabels
  ! x_* en t_* are given as log_10
  double precision, allocatable :: y_PPL(:), t_PPL(:), l_PPL(:), a_PPL(:)

  integer :: n_PPL

  logical :: isPPL = .false.

  integer          :: n_Hildner, n_FM, n_RP, n_Klimchuk

  double precision :: t_Hildner(1:6), t_FM(1:5), t_RP(1:10), t_Klimchuk(1:8)

  double precision :: x_Hildner(1:5), x_FM(1:4), x_RP(1:9), x_Klimchuk(1:7)

  double precision :: a_Hildner(1:5), a_FM(1:4), a_RP(1:9), a_Klimchuk(1:7)

  data   n_Hildner / 5 /
 
  data   t_Hildner / 3.00000, 4.17609, 4.90309, 5.47712, 5.90309, 10.00000 /

  data   x_Hildner / -53.30803, -29.92082, -21.09691, -7.40450, -16.25885 /
  
  data   a_Hildner / 7.4, 1.8, 0.0, -2.5, -1.0 /

  data   n_FM / 4 /
 
  data   t_FM / 3.00000, 4.30103, 5.60206, 7.00000, 10.00000 /

  data   x_FM / -31.15813, -27.50227, -18.25885, -35.75893 /
  
  data   a_FM / 2.0, 1.15, -0.5, 2.0 /

  data   n_RP / 9 /
 
  data   t_RP / 3.00000, 3.89063, 4.30195, 4.57500,  4.90000, &
                5.40000, 5.77000, 6.31500, 7.60457, 10.00000  /

  data   x_RP / -69.900, -48.307, -21.850, -31.000, -21.200, &
                -10.400, -21.940, -17.730, -26.602           /
  
  data   a_RP / 11.70, 6.15, 0.00, 2.00, 0.00, &
                -2.00, 0.00, -0.67, 0.50       /

  data   n_Klimchuk / 7 /
  
  data   t_Klimchuk / 3.00, 4.97, 5.67, 6.18, 6.55, 6.90, 7.63, 10.00 /

  data   x_Klimchuk / -30.96257, -16.05208, -21.72125, -12.45223, &
                      -24.46092, -15.26043, -26.70774             /

  data   a_Klimchuk / 2.00, -1.00, 0.00, -1.50, 0.33, -1.00, 0.50 /


  ! Interpolatable tables
  integer          :: n_DM      , n_MB      , n_MLcosmol &
                    , n_MLwc    , n_MLsolar1, n_SPEX     &
                    , n_JCcorona, n_cl_ism  , n_cl_solar &
                    , n_DM_2    , n_Dere    , n_Colgan
  
  double precision :: t_DM(1:71),       t_MB(1:51),       t_MLcosmol(1:71) &
                    , t_MLwc(1:71),     t_MLsolar1(1:71), t_SPEX(1:110)    &
                    , t_JCcorona(1:45), t_cl_ism(1:151),  t_cl_solar(1:151)&
                    , t_DM_2(1:76),     t_Dere(1:101),    t_Colgan(1:55) 
  
  double precision :: l_DM(1:71),       l_MB(1:51),           l_MLcosmol(1:71)   &
                    , l_MLwc(1:71),     l_MLsolar1(1:71),     l_SPEX(1:110)      &
                    , l_JCcorona(1:45), l_cl_ism(1:151),      l_cl_solar(1:151)  &
                    , l_DM_2(1:76),     l_Dere_corona(1:101), l_Dere_photo(1:101)&
                    , l_Colgan(1:55)
  
  double precision :: nenh_SPEX(1:110)
  
  data    n_JCcorona / 45 /
  
  data    t_JCcorona / 4.00000, 4.14230, 4.21995, 4.29761, 4.37528, &
                       4.45294, 4.53061, 4.60827, 4.68593, 4.76359, &
                       4.79705, 4.83049, 4.86394, 4.89739, 4.93084, &
                       4.96428, 4.99773, 5.03117, 5.06461, 5.17574, &
                       5.28684, 5.39796, 5.50907, 5.62018, 5.73129, &
                       5.84240, 5.95351, 6.06461, 6.17574, 6.28684, &
                       6.39796, 6.50907, 6.62018, 6.73129, 6.84240, &
                       6.95351, 7.06461, 7.17574, 7.28684, 7.39796, &
                       7.50907, 7.62018, 7.73129, 7.84240, 7.95351  /
  
  data    l_JCcorona / -200.18883, -100.78630, -30.60384, -22.68481, -21.76445, &
                       -21.67936, -21.54218, -21.37958, -21.25172, -21.17584, &
                       -21.15783, -21.14491, -21.13527, -21.12837, -21.12485, &
                       -21.12439, -21.12642, -21.12802, -21.12548, -21.08965, &
                       -21.08812, -21.19542, -21.34582, -21.34839, -21.31701, &
                       -21.29072, -21.28900, -21.34104, -21.43122, -21.62448, &
                       -21.86694, -22.02897, -22.08051, -22.06057, -22.01973, &
                       -22.00000, -22.05161, -22.22175, -22.41452, -22.52581, &
                       -22.56914, -22.57486, -22.56151, -22.53969, -22.51490  /
  
  data    n_DM / 71 /
  
  data    t_DM / 2.0, 2.1, 2.2, 2.3, 2.4, &
                 2.5, 2.6, 2.7, 2.8, 2.9, &
                 3.0, 3.1, 3.2, 3.3, 3.4, &
                 3.5, 3.6, 3.7, 3.8, 3.9, &
                 4.0, 4.1, 4.2, 4.3, 4.4, &
                 4.5, 4.6, 4.7, 4.8, 4.9, &
                 5.0, 5.1, 5.2, 5.3, 5.4, &
                 5.5, 5.6, 5.7, 5.8, 5.9, &
                 6.0, 6.1, 6.2, 6.3, 6.4, &
                 6.5, 6.6, 6.7, 6.8, 6.9, &
                 7.0, 7.1, 7.2, 7.3, 7.4, &
                 7.5, 7.6, 7.7, 7.8, 7.9, &
                 8.0, 8.1, 8.2, 8.3, 8.4, &
                 8.5, 8.6, 8.7, 8.8, 8.9, &
                 9.0 /
  
  
  data    l_DM / -26.523, -26.398, -26.301, -26.222, -26.097 & 
               , -26.011, -25.936, -25.866, -25.807, -25.754 &
               , -25.708, -25.667, -25.630, -25.595, -25.564 &
               , -25.534, -25.506, -25.479, -25.453, -25.429 &
               , -25.407, -23.019, -21.762, -21.742, -21.754 &
               , -21.730, -21.523, -21.455, -21.314, -21.229 &
               , -21.163, -21.126, -21.092, -21.060, -21.175 &
               , -21.280, -21.390, -21.547, -21.762, -22.050 &
               , -22.271, -22.521, -22.646, -22.660, -22.676 &
               , -22.688, -22.690, -22.662, -22.635, -22.609 &
               , -22.616, -22.646, -22.697, -22.740, -22.788 &
               , -22.815, -22.785, -22.754, -22.728, -22.703 &
               , -22.680, -22.630, -22.580, -22.530, -22.480 & 
               , -22.430, -22.380, -22.330, -22.280, -22.230 &
               , -22.180 /
                 
  data    n_MB / 51 /
  
  data    t_MB / 4.0, 4.1, 4.2, 4.3, 4.4, &
                 4.5, 4.6, 4.7, 4.8, 4.9, &
                 5.0, 5.1, 5.2, 5.3, 5.4, &
                 5.5, 5.6, 5.7, 5.8, 5.9, &
                 6.0, 6.1, 6.2, 6.3, 6.4, &
                 6.5, 6.6, 6.7, 6.8, 6.9, &
                 7.0, 7.1, 7.2, 7.3, 7.4, &
                 7.5, 7.6, 7.7, 7.8, 7.9, &
                 8.0, 8.1, 8.2, 8.3, 8.4, &
                 8.5, 8.6, 8.7, 8.8, 8.9, &
                 9.0 /
        
  data    l_MB  / -23.133, -22.895, -22.548, -22.285, -22.099 &
                , -21.970, -21.918, -21.826, -21.743, -21.638 &
                , -21.552, -21.447, -21.431, -21.418, -21.461 &
                , -21.570, -21.743, -21.832, -21.908, -21.981 &
                , -22.000, -21.998, -21.992, -22.013, -22.095 &
                , -22.262, -22.397, -22.445, -22.448, -22.446 &
                , -22.448, -22.465, -22.575, -22.725, -22.749 &
                , -22.768, -22.753, -22.717, -22.678, -22.637 &
                , -22.603, -22.553, -22.503, -22.453, -22.403 &
                , -22.353, -22.303, -22.253, -22.203, -22.153 &
                , -22.103 /
  
  data    n_MLcosmol / 71 /
  
  data    t_MLcosmol / &
                 2.0, 2.1, 2.2, 2.3, 2.4, &
                 2.5, 2.6, 2.7, 2.8, 2.9, &
                 3.0, 3.1, 3.2, 3.3, 3.4, &
                 3.5, 3.6, 3.7, 3.8, 3.9, &
                 4.0, 4.1, 4.2, 4.3, 4.4, &
                 4.5, 4.6, 4.7, 4.8, 4.9, &
                 5.0, 5.1, 5.2, 5.3, 5.4, &
                 5.5, 5.6, 5.7, 5.8, 5.9, &
                 6.0, 6.1, 6.2, 6.3, 6.4, &
                 6.5, 6.6, 6.7, 6.8, 6.9, &
                 7.0, 7.1, 7.2, 7.3, 7.4, &
                 7.5, 7.6, 7.7, 7.8, 7.9, &
                 8.0, 8.1, 8.2, 8.3, 8.4, &
                 8.5, 8.6, 8.7, 8.8, 8.9, &
                 9.0 /
        
  data    l_MLcosmol / &
                 -99.000, -99.000, -99.000, -99.000, -99.000 & 
               , -99.000, -99.000, -99.000, -99.000, -99.000 &
               , -99.000, -99.000, -99.000, -99.000, -99.000 &
               , -99.000, -44.649, -38.362, -33.324, -29.292 &
               , -26.063, -23.532, -22.192, -22.195, -22.454 &
               , -22.676, -22.909, -22.925, -22.499, -22.276 &
               , -22.440, -22.688, -22.917, -23.116, -23.274 &
               , -23.394, -23.472, -23.516, -23.530, -23.525 &
               , -23.506, -23.478, -23.444, -23.408, -23.368 &
               , -23.328, -23.286, -23.244, -23.201, -23.157 &
               , -23.114, -23.070, -23.026, -22.981, -22.937 &
               , -22.893, -22.848, -22.803, -22.759, -22.714 &
               , -22.669, -22.619, -22.569, -22.519, -22.469 &
               , -22.419, -22.369, -22.319, -22.269, -22.190 &
               , -22.169 /
  
  data    n_MLwc / 71 /
  
  data    t_MLwc / &
                 2.0, 2.1, 2.2, 2.3, 2.4, &
                 2.5, 2.6, 2.7, 2.8, 2.9, &
                 3.0, 3.1, 3.2, 3.3, 3.4, &
                 3.5, 3.6, 3.7, 3.8, 3.9, &
                 4.0, 4.1, 4.2, 4.3, 4.4, &
                 4.5, 4.6, 4.7, 4.8, 4.9, &
                 5.0, 5.1, 5.2, 5.3, 5.4, &
                 5.5, 5.6, 5.7, 5.8, 5.9, &
                 6.0, 6.1, 6.2, 6.3, 6.4, &
                 6.5, 6.6, 6.7, 6.8, 6.9, &
                 7.0, 7.1, 7.2, 7.3, 7.4, &
                 7.5, 7.6, 7.7, 7.8, 7.9, &
                 8.0, 8.1, 8.2, 8.3, 8.4, &
                 8.5, 8.6, 8.7, 8.8, 8.9, &
                 9.0 /
        
  data    l_MLwc / &
                 -21.192, -21.160, -21.150, -21.150, -21.166 & 
               , -21.191, -21.222, -21.264, -21.308, -21.357 &
               , -21.408, -21.449, -21.494, -21.544, -21.587 &
               , -21.638, -21.686, -21.736, -21.780, -21.800 &
               , -21.744, -21.547, -21.208, -20.849, -20.345 &
               , -19.771, -19.409, -19.105, -18.827, -18.555 &
               , -18.460, -18.763, -19.168, -19.334, -19.400 &
               , -19.701, -20.090, -20.288, -20.337, -20.301 &
               , -20.233, -20.275, -20.363, -20.508, -20.675 &
               , -20.856, -21.025, -21.159, -21.256, -21.320 &
               , -21.354, -21.366, -21.361, -21.343, -21.317 &
               , -21.285, -21.250, -21.212, -21.172, -21.131 &
               , -21.089, -21.039, -20.989, -20.939, -20.889 &
               , -20.839, -20.789, -20.739, -20.689, -20.639 & 
               , -20.589 /
  
  data n_MLsolar1 / 71 /
  
  data    t_MLsolar1 / &
                       2.0, 2.1, 2.2, 2.3, 2.4, &
                       2.5, 2.6, 2.7, 2.8, 2.9, &
                        3.0, 3.1, 3.2, 3.3, 3.4, &
                       3.5, 3.6, 3.7, 3.8, 3.9, &
                       4.0, 4.1, 4.2, 4.3, 4.4, &
                       4.5, 4.6, 4.7, 4.8, 4.9, &
                       5.0, 5.1, 5.2, 5.3, 5.4, &
                       5.5, 5.6, 5.7, 5.8, 5.9, &
                       6.0, 6.1, 6.2, 6.3, 6.4, &
                       6.5, 6.6, 6.7, 6.8, 6.9, &
                       7.0, 7.1, 7.2, 7.3, 7.4, &
                       7.5, 7.6, 7.7, 7.8, 7.9, &
                       8.0, 8.1, 8.2, 8.3, 8.4, &
                       8.5, 8.6, 8.7, 8.8, 8.9, &
                       9.0 /
        
  data    l_MLsolar1 / &
                       -26.983, -26.951, -26.941, -26.940, -26.956 &
                     , -26.980, -27.011, -27.052, -27.097, -27.145 &
                     , -27.195, -27.235, -27.279, -27.327, -27.368 &
                     , -27.415, -27.456, -27.485, -27.468, -27.223 &
                     , -25.823, -23.501, -22.162, -22.084, -22.157 &
                     , -22.101, -21.974, -21.782, -21.542, -21.335 &
                     , -21.251, -21.275, -21.236, -21.173, -21.167 &
                     , -21.407, -21.670, -21.788, -21.879, -22.008 &
                     , -22.192, -22.912, -22.918, -22.887, -22.929 &
                     , -23.023, -23.094, -23.117, -23.108, -23.083 &
                     , -23.049, -23.011, -22.970, -22.928, -22.885 &
                     , -22.842, -22.798, -22.754, -22.709, -22.665 &
                     , -22.620, -22.570, -22.520, -22.470, -22.420 &
                     , -22.370, -22.320, -22.270, -22.220, -22.170 &
                     , -22.120 /
  
  
  data n_SPEX / 110 /
  
  data    t_SPEX / &
                       3.80, 3.84, 3.88, 3.92, 3.96, &
                       4.00, 4.04, 4.08, 4.12, 4.16, &
                       4.20, 4.24, 4.28, 4.32, 4.36, &
                       4.40, 4.44, 4.48, 4.52, 4.56, &
                       4.60, 4.64, 4.68, 4.72, 4.76, &
                       4.80, 4.84, 4.88, 4.92, 4.96, &
                       5.00, 5.04, 5.08, 5.12, 5.16, &
                       5.20, 5.24, 5.28, 5.32, 5.36, &
                       5.40, 5.44, 5.48, 5.52, 5.56, &
                       5.60, 5.64, 5.68, 5.72, 5.76, &
                       5.80, 5.84, 5.88, 5.92, 5.96, &
                       6.00, 6.04, 6.08, 6.12, 6.16, &
                       6.20, 6.24, 6.28, 6.32, 6.36, &
                       6.40, 6.44, 6.48, 6.52, 6.56, &
                       6.60, 6.64, 6.68, 6.72, 6.76, &
                       6.80, 6.84, 6.88, 6.92, 6.96, &
                       7.00, 7.04, 7.08, 7.12, 7.16, &
                       7.20, 7.24, 7.28, 7.32, 7.36, &
                       7.40, 7.44, 7.48, 7.52, 7.56, &
                       7.60, 7.64, 7.68, 7.72, 7.76, &
                       7.80, 7.84, 7.88, 7.92, 7.96, &
                       8.00, 8.04, 8.08, 8.12, 8.16  /
        
  data    l_SPEX / &
                      -25.7331, -25.0383, -24.4059, -23.8288, -23.3027 &
                    , -22.8242, -22.3917, -22.0067, -21.6818, -21.4529 &
                    , -21.3246, -21.3459, -21.4305, -21.5293, -21.6138 &
                    , -21.6615, -21.6551, -21.5919, -21.5092, -21.4124 &
                    , -21.3085, -21.2047, -21.1067, -21.0194, -20.9413 &
                    , -20.8735, -20.8205, -20.7805, -20.7547, -20.7455 &
                    , -20.7565, -20.7820, -20.8008, -20.7994, -20.7847 &
                    , -20.7687, -20.7590, -20.7544, -20.7505, -20.7545 &
                    , -20.7888, -20.8832, -21.0450, -21.2286, -21.3737 &
                    , -21.4573, -21.4935, -21.5098, -21.5345, -21.5863 &
                    , -21.6548, -21.7108, -21.7424, -21.7576, -21.7696 &
                    , -21.7883, -21.8115, -21.8303, -21.8419, -21.8514 &
                    , -21.8690, -21.9057, -21.9690, -22.0554, -22.1488 &
                    , -22.2355, -22.3084, -22.3641, -22.4033, -22.4282 &
                    , -22.4408, -22.4443, -22.4411, -22.4334, -22.4242 &
                    , -22.4164, -22.4134, -22.4168, -22.4267, -22.4418 &
                    , -22.4603, -22.4830, -22.5112, -22.5449, -22.5819 &
                    , -22.6177, -22.6483, -22.6719, -22.6883, -22.6985 &
                    , -22.7032, -22.7037, -22.7008, -22.6950, -22.6869 &
                    , -22.6769, -22.6655, -22.6531, -22.6397, -22.6258 &
                    , -22.6111, -22.5964, -22.5816, -22.5668, -22.5519 &
                    , -22.5367, -22.5216, -22.5062, -22.4912, -22.4753 /
  
  
  data    nenh_SPEX / &
            0.000013264, 0.000042428, 0.000088276, 0.00017967 &
          , 0.00084362,  0.0034295,   0.013283,    0.042008   &
          , 0.12138,     0.30481,     0.53386,     0.76622    &
          , 0.89459,     0.95414,     0.98342 &
          , 1.0046,    1.0291,    1.0547    &
          , 1.0767,    1.0888    &
          , 1.0945,    1.0972,    1.0988    &
          , 1.1004,    1.1034    &
          , 1.1102,    1.1233,    1.1433    &
          , 1.1638,    1.1791    &
          , 1.1885,    1.1937,    1.1966    &
          , 1.1983,    1.1993    &
          , 1.1999,    1.2004,    1.2008    &
          , 1.2012,    1.2015    &
          , 1.2020,    1.2025,    1.2030    &
          , 1.2035,    1.2037    &
          , 1.2039,    1.2040,    1.2041    &
          , 1.2042,    1.2044    &
          , 1.2045,    1.2046,    1.2047    &
          , 1.2049,    1.2050    &
          , 1.2051,    1.2053,    1.2055    &
          , 1.2056,    1.2058    &
          , 1.2060,    1.2062,    1.2065    &
          , 1.2067,    1.2070    &
          , 1.2072,    1.2075,    1.2077    &
          , 1.2078,    1.2079    &
          , 1.2080,    1.2081,    1.2082    &
          , 1.2083,    1.2083    &
          , 1.2084,    1.2084,    1.2085    &
          , 1.2085,    1.2086    &
          , 1.2086,    1.2087,    1.2087    &
          , 1.2088,    1.2088    &
          , 1.2089,    1.2089,    1.2089    &
          , 1.2089,    1.2089    &
          , 1.2090,    1.2090,    1.2090    &
          , 1.2090,    1.2090    &
          , 1.2090,    1.2090,    1.2090    &
          , 1.2090,    1.2090    &
          , 1.2090,    1.2090,    1.2090    &
          , 1.2090,    1.2090    &
          , 1.2090,    1.2090,    1.2090    &
          , 1.2090,    1.2090    /   
  !
  ! To be used together with the SPEX table for the SPEX_DM option
  ! Assuming an ionization fraction of 10^-3
  !
  data    n_DM_2 / 76 /
  
  data    t_DM_2 / 1.00, 1.04, 1.08, 1.12, 1.16, 1.20 &
                 , 1.24, 1.28, 1.32, 1.36, 1.40 &
                 , 1.44, 1.48, 1.52, 1.56, 1.60 &
                 , 1.64, 1.68, 1.72, 1.76, 1.80 &
                 , 1.84, 1.88, 1.92, 1.96, 2.00 &
                 , 2.04, 2.08, 2.12, 2.16, 2.20 &
                 , 2.24, 2.28, 2.32, 2.36, 2.40 &
                 , 2.44, 2.48, 2.52, 2.56, 2.60 & 
                 , 2.64, 2.68, 2.72, 2.76, 2.80 &
                 , 2.84, 2.88, 2.92, 2.96, 3.00 &
                 , 3.04, 3.08, 3.12, 3.16, 3.20 &
                 , 3.24, 3.28, 3.32, 3.36, 3.40 &
                 , 3.44, 3.48, 3.52, 3.56, 3.60 & 
                 , 3.64, 3.68, 3.72, 3.76, 3.80 &
                 , 3.84, 3.88, 3.92, 3.96, 4.00 /
  
  
  data    l_DM_2 / -30.0377, -29.7062, -29.4055, -29.1331, -28.8864, -28.6631 &
                 , -28.4614, -28.2791, -28.1146, -27.9662, -27.8330 &
                 , -27.7129, -27.6052, -27.5088, -27.4225, -27.3454 &
                 , -27.2767, -27.2153, -27.1605, -27.1111, -27.0664 &
                 , -27.0251, -26.9863, -26.9488, -26.9119, -26.8742 &
                 , -26.8353, -26.7948, -26.7523, -26.7080, -26.6619 &
                 , -26.6146, -26.5666, -26.5183, -26.4702, -26.4229 &
                 , -26.3765, -26.3317, -26.2886, -26.2473, -26.2078 &
                 , -26.1704, -26.1348, -26.1012, -26.0692, -26.0389 &
                 , -26.0101, -25.9825, -25.9566, -25.9318, -25.9083 &
                 , -25.8857, -25.8645, -25.8447, -25.8259, -25.8085 &
                 , -25.7926, -25.7778, -25.7642, -25.7520, -25.7409 &
                 , -25.7310, -25.7222, -25.7142, -25.7071, -25.7005 &
                 , -25.6942, -25.6878, -25.6811, -25.6733, -25.6641 &
                 , -25.6525, -25.6325, -25.6080, -25.5367, -25.4806  /
  
  data n_cl_solar / 151 /
  
  data    t_cl_solar /    &
     1.000   ,   1.050   ,   1.100   ,   1.150   , &
     1.200   ,   1.250   ,   1.300   ,   1.350   , &
     1.400   ,   1.450   ,   1.500   ,   1.550   , &
     1.600   ,   1.650   ,   1.700   ,   1.750   , &
     1.800   ,   1.850   ,   1.900   ,   1.950   , &
     2.000   ,   2.050   ,   2.100   ,   2.150   , &
     2.200   ,   2.250   ,   2.300   ,   2.350   , & 
     2.400   ,   2.450   ,   2.500   ,   2.550   , &
     2.600   ,   2.650   ,   2.700   ,   2.750   , &
     2.800   ,   2.850   ,   2.900   ,   2.950   , &
     3.000   ,   3.050   ,   3.100   ,   3.150   , &
     3.200   ,   3.250   ,   3.300   ,   3.350   , &
     3.400   ,   3.450   ,   3.500   ,   3.550   , &
     3.600   ,   3.650   ,   3.700   ,   3.750   , &
     3.800   ,   3.850   ,   3.900   ,   3.950   , &
     4.000   ,   4.050   ,   4.100   ,   4.150   , &
     4.200   ,   4.250   ,   4.300   ,   4.350   , &
     4.400   ,   4.450   ,   4.500   ,   4.550   , &
     4.600   ,   4.650   ,   4.700   ,   4.750   , &
     4.800   ,   4.850   ,   4.900   ,   4.950   , &
     5.000   ,   5.050   ,   5.100   ,   5.150   , &
     5.200   ,   5.250   ,   5.300   ,   5.350   , &
     5.400   ,   5.450   ,   5.500   ,   5.550   , &
     5.600   ,   5.650   ,   5.700   ,   5.750   , &
     5.800   ,   5.850   ,   5.900   ,   5.950   , &
     6.000   ,   6.050   ,   6.100   ,   6.150   , &
     6.200   ,   6.250   ,   6.300   ,   6.350   , &
     6.400   ,   6.450   ,   6.500   ,   6.550   , &
     6.600   ,   6.650   ,   6.700   ,   6.750   , &
     6.800   ,   6.850   ,   6.900   ,   6.950   , &
     7.000   ,   7.050   ,   7.100   ,   7.150   , &
     7.200   ,   7.250   ,   7.300   ,   7.350   , &
     7.400   ,   7.450   ,   7.500   ,   7.550   , &
     7.600   ,   7.650   ,   7.700   ,   7.750   , &
     7.800   ,   7.850   ,   7.900   ,   7.950   , &
     8.000   ,   8.100   ,   8.200   ,   8.300   , &
     8.400   ,   8.500   ,   8.600   ,   8.700   , &
     8.800   ,   8.900   ,   9.00  / 
  
  
  data    l_cl_solar / &
   -28.375   , -28.251   , -28.137   , -28.029   , &
   -27.929   , -27.834   , -27.745   , -27.662   , &
   -27.584   , -27.512   , -27.445   , -27.383   , &
   -27.326   , -27.273   , -27.223   , -27.175   , &
   -27.128   , -27.079   , -27.027   , -26.972   , &
   -26.911   , -26.846   , -26.777   , -26.705   , &
   -26.632   , -26.554   , -26.479   , -26.407   , &
   -26.338   , -26.274   , -26.213   , -26.156   , &
   -26.101   , -26.049   , -25.999   , -25.949   , &
   -25.901   , -25.852   , -25.803   , -25.754   , &
   -25.707   , -25.662   , -25.621   , -25.588   , &
   -25.561   , -25.538   , -25.518   , -25.497   , &
   -25.475   , -25.452   , -25.426   , -25.400   , &
   -25.374   , -25.333   , -25.295   , -25.261   , &
   -25.228   , -25.189   , -25.136   , -25.053   , &
   -24.888   , -24.454   , -23.480   , -22.562   , &
   -22.009   , -21.826   , -21.840   , -21.905   , &
   -21.956   , -21.971   , -21.958   , -21.928   , &
   -21.879   , -21.810   , -21.724   , -21.623   , &
   -21.512   , -21.404   , -21.321   , -21.273   , &
   -21.250   , -21.253   , -21.275   , -21.287   , &
   -21.282   , -21.275   , -21.272   , -21.267   , &
   -21.281   , -21.357   , -21.496   , -21.616   , &
   -21.677   , -21.698   , -21.708   , -21.730   , &
   -21.767   , -21.793   , -21.794   , -21.787   , &
   -21.787   , -21.802   , -21.826   , -21.859   , &
   -21.911   , -21.987   , -22.082   , -22.173   , &
   -22.253   , -22.325   , -22.392   , -22.448   , &
   -22.487   , -22.512   , -22.524   , -22.528   , &
   -22.524   , -22.516   , -22.507   , -22.501   , &
   -22.502   , -22.511   , -22.533   , -22.565   , &
   -22.600   , -22.630   , -22.648   , -22.656   , &
   -22.658   , -22.654   , -22.647   , -22.634   , &
   -22.619   , -22.602   , -22.585   , -22.566   , &
   -22.546   , -22.525   , -22.505   , -22.480   , &
   -22.465   , -22.415   , -22.365   , -22.315   , &
   -22.265   , -22.215   , -22.165   , -22.115   , &
   -22.065   , -22.015   , -21.965   / 
  
  
  data n_cl_ism / 151 /
  
  data t_cl_ism / &
     1.000   ,   1.050   ,   1.100   ,   1.150   , &
     1.200   ,   1.250   ,   1.300   ,   1.350   , &
     1.400   ,   1.450   ,   1.500   ,   1.550   , &
     1.600   ,   1.650   ,   1.700   ,   1.750   , &
     1.800   ,   1.850   ,   1.900   ,   1.950   , &
     2.000   ,   2.050   ,   2.100   ,   2.150   , &
     2.200   ,   2.250   ,   2.300   ,   2.350   , &
     2.400   ,   2.450   ,   2.500   ,   2.550   , &
     2.600   ,   2.650   ,   2.700   ,   2.750   , &
     2.800   ,   2.850   ,   2.900   ,   2.950   , &
     3.000   ,   3.050   ,   3.100   ,   3.150   , &
     3.200   ,   3.250   ,   3.300   ,   3.350   , &
     3.400   ,   3.450   ,   3.500   ,   3.550   , &
     3.600   ,   3.650   ,   3.700   ,   3.750   , &
     3.800   ,   3.850   ,   3.900   ,   3.950   , &
     4.000   ,   4.050   ,   4.100   ,   4.150   , &
     4.200   ,   4.250   ,   4.300   ,   4.350   , &
     4.400   ,   4.450   ,   4.500   ,   4.550   , &
     4.600   ,   4.650   ,   4.700   ,   4.750   , &
     4.800   ,   4.850   ,   4.900   ,   4.950   , &
     5.000   ,   5.050   ,   5.100   ,   5.150   , &
     5.200   ,   5.250   ,   5.300   ,   5.350   , &
     5.400   ,   5.450   ,   5.500   ,   5.550   , &
     5.600   ,   5.650   ,   5.700   ,   5.750   , &
     5.800   ,   5.850   ,   5.900   ,   5.950   , &
     6.000   ,   6.050   ,   6.100   ,   6.150   , &
     6.200   ,   6.250   ,   6.300   ,   6.350   , &
     6.400   ,   6.450   ,   6.500   ,   6.550   , &
     6.600   ,   6.650   ,   6.700   ,   6.750   , &
     6.800   ,   6.850   ,   6.900   ,   6.950   , &
     7.000   ,   7.050   ,   7.100   ,   7.150   , &
     7.200   ,   7.250   ,   7.300   ,   7.350   , &
     7.400   ,   7.450   ,   7.500   ,   7.550   , &
     7.600   ,   7.650   ,   7.700   ,   7.750   , &
     7.800   ,   7.850   ,   7.900   ,   7.950   , &
     8.000   ,   8.100   ,   8.200   ,   8.300   , &
     8.400   ,   8.500   ,   8.600   ,   8.700   , &
     8.800   ,   8.900   ,   9.00    /
  
  data l_cl_ism / &
   -28.365   , -28.242   , -28.127   , -28.020   , &
   -27.919   , -27.825   , -27.736   , -27.653   , &
   -27.575   , -27.504   , -27.437   , -27.376   , &
   -27.319   , -27.267   , -27.220   , -27.176   , &
   -27.134   , -27.095   , -27.058   , -27.021   , &
   -26.985   , -26.948   , -26.910   , -26.870   , &
   -26.827   , -26.775   , -26.721   , -26.664   , &
   -26.608   , -26.552   , -26.495   , -26.437   , &
   -26.378   , -26.317   , -26.255   , -26.190   , &
   -26.123   , -26.053   , -25.984   , -25.913   , &
   -25.847   , -25.786   , -25.736   , -25.702   , &
   -25.678   , -25.662   , -25.649   , -25.636   , &
   -25.621   , -25.604   , -25.587   , -25.571   , &
   -25.562   , -25.526   , -25.505   , -25.499   , &
   -25.499   , -25.491   , -25.468   , -25.410   , &
   -25.268   , -24.888   , -23.702   , -22.624   , &
   -22.036   , -21.843   , -21.854   , -21.924   , &
   -21.986   , -22.017   , -22.021   , -22.005   , &
   -21.964   , -21.896   , -21.806   , -21.699   , &
   -21.580   , -21.463   , -21.370   , -21.312   , &
   -21.284   , -21.290   , -21.322   , -21.345   , & 
   -21.354   , -21.366   , -21.385   , -21.396   , &
   -21.414   , -21.483   , -21.600   , -21.696   , &
   -21.742   , -21.759   , -21.776   , -21.816   , &
   -21.885   , -21.939   , -21.946   , -21.918   , &
   -21.873   , -21.818   , -21.756   , -21.689   , &
   -21.618   , -21.547   , -21.475   , -21.403   , &
   -21.331   , -21.260   , -21.188   , -21.114   , &
   -21.039   , -20.963   , -20.887   , -20.810   , &
   -20.734   , -20.657   , -20.581   , -20.505   , &
   -20.429   , -20.352   , -20.276   , -20.200   , &
   -20.125   , -20.049   , -19.973   , -19.898   , &
   -19.822   , -19.747   , -19.671   , -19.596   , &
   -19.520   , -19.445   , -19.370   , -19.295   , &
   -19.220   , -19.144   , -19.069   , -18.994   , &
   -18.919   , -18.869   , -18.819   , -18.769   , &
   -18.719   , -18.669   , -18.619   , -18.569   , &
   -18.519   , -18.469   , -18.419   /

  data    n_Dere / 101 /
  
  data    t_Dere / 4.00, 4.05, 4.10, 4.15, 4.20, 4.25, 4.30, 4.35, &
                   4.40, 4.45, 4.50, 4.55, 4.60, 4.65, 4.70, 4.75, &
                   4.80, 4.85, 4.90, 4.95, 5.00, 5.05, 5.10, 5.15, &
                   5.20, 5.25, 5.30, 5.35, 5.40, 5.45, 5.50, 5.55, &
                   5.60, 5.65, 5.70, 5.75, 5.80, 5.85, 5.90, 5.95, &
                   6.00, 6.05, 6.10, 6.15, 6.20, 6.25, 6.30, 6.35, &
                   6.40, 6.45, 6.50, 6.55, 6.60, 6.65, 6.70, 6.75, &
                   6.80, 6.85, 6.90, 6.95, 7.00, 7.05, 7.10, 7.15, &
                   7.20, 7.25, 7.30, 7.35, 7.40, 7.45, 7.50, 7.55, &
                   7.60, 7.65, 7.70, 7.75, 7.80, 7.85, 7.90, 7.95, &
                   8.00, 8.05, 8.10, 8.15, 8.20, 8.25, 8.30, 8.35, &
                   8.40, 8.45, 8.50, 8.55, 8.60, 8.65, 8.70, 8.75, &
                   8.80, 8.85, 8.90, 8.95, 9.00                    /
  
  data    l_Dere_corona / &
 -23.00744648, -22.55439580, -22.15614458, -21.83268267, -21.64589156, &
 -21.61618463, -21.68402965, -21.79048499, -21.87614836, -21.91009489, &
 -21.89962945, -21.86012091, -21.79588002, -21.71669877, -21.62342304, &
 -21.52143350, -21.41793664, -21.33068312, -21.27736608, -21.25181197, &
 -21.24184538, -21.25806092, -21.27901426, -21.27164622, -21.24412514, &
 -21.21467016, -21.19586057, -21.18309616, -21.18708664, -21.24108811, &
 -21.35163999, -21.45099674, -21.48678240, -21.47625353, -21.45222529, &
 -21.43297363, -21.42596873, -21.42021640, -21.41005040, -21.40120949, &
 -21.40450378, -21.42250820, -21.44977165, -21.47755577, -21.51144928, &
 -21.55909092, -21.63451202, -21.73754891, -21.85078089, -21.95467702, &
 -22.03526908, -22.08990945, -22.11804503, -22.12436006, -22.11633856, &
 -22.10072681, -22.08301995, -22.06701918, -22.05650548, -22.05551733, &
 -22.06803389, -22.10072681, -22.15926677, -22.24033216, -22.32882716, &
 -22.40782324, -22.47108330, -22.51855737, -22.54975089, -22.57024772, &
 -22.58004425, -22.58335949, -22.58169871, -22.57511836, -22.56543110, &
 -22.55439580, -22.54060751, -22.52724355, -22.51427857, -22.49894074, &
 -22.48545225, -22.47108330, -22.45593196, -22.44009337, -22.42365865, &
 -22.40671393, -22.38933984, -22.37059040, -22.35163999, -22.33161408, &
 -22.31158018, -22.29073004, -22.26921772, -22.24795155, -22.22621356, &
 -22.20411998, -22.18111459, -22.15864053, -22.13608262, -22.11294562, &
 -22.08937560                                                          /

  data    l_Dere_photo / &
 -23.25649024, -22.74232143, -22.28988263, -21.93554201, -21.74232143, &
 -21.72353820, -21.80410035, -21.91009489, -22.00000000, -22.04143612, &
 -22.04575749, -22.02502801, -21.97469413, -21.89962945, -21.80410035, &
 -21.69250396, -21.57511836, -21.46852108, -21.38827669, -21.33629907, &
 -21.31069114, -21.31966449, -21.33724217, -21.32882716, -21.30189945, &
 -21.27408837, -21.25649024, -21.24718357, -21.25649024, -21.32148162, &
 -21.46092390, -21.61083392, -21.70774393, -21.74958000, -21.76955108, &
 -21.79588002, -21.84466396, -21.88941029, -21.91009489, -21.91721463, &
 -21.92811799, -21.94692156, -21.96657624, -21.99139983, -22.01412464, &
 -22.04963515, -22.10402527, -22.17848647, -22.26201267, -22.34390180, &
 -22.41680123, -22.47237010, -22.50723961, -22.52578374, -22.53313238, &
 -22.53165267, -22.52578374, -22.51855737, -22.51286162, -22.51286162, &
 -22.52143350, -22.54211810, -22.57839607, -22.62708800, -22.67366414, &
 -22.70996539, -22.73282827, -22.74714697, -22.75202673, -22.74958000, &
 -22.74232143, -22.73282827, -22.72124640, -22.70553377, -22.69036983, &
 -22.67162040, -22.65364703, -22.63638802, -22.61618463, -22.59687948, &
 -22.57675413, -22.55752023, -22.53610701, -22.51570016, -22.49485002, &
 -22.47366072, -22.45222529, -22.42945706, -22.40782324, -22.38510278, &
 -22.36251027, -22.33913452, -22.31605287, -22.29242982, -22.26921772, &
 -22.24565166, -22.22184875, -22.19859629, -22.17457388, -22.15058059, &
 -22.12609840                                                          /           

  data    n_Colgan / 55 /
  
  data    t_Colgan / 4.06460772, 4.14229559, 4.21995109, 4.29760733, 4.37527944, 4.45293587, &
                     4.53060946, 4.60826923, 4.68592974, 4.76359269, 4.79704583, 4.83049243, &
                     4.86394114, 4.89738514, 4.93083701, 4.96428321, 4.99773141, 5.03116600, &
                     5.06460772, 5.17574368, 5.28683805, 5.39795738, 5.50906805, 5.62017771, &
                     5.73129054, 5.84240328, 5.95351325, 6.06460772, 6.17574368, 6.28683805, &
                     6.39795738, 6.50906805, 6.62017771, 6.73129054, 6.84240328, 6.95351325, &
                     7.06460772, 7.17574368, 7.28683805, 7.39795738, 7.50906805, 7.62017771, &
                     7.73129054, 7.84240328, 7.95351325, 8.06460772, 8.17574368, 8.28683805, &
                     8.39795738, 8.50906805, 8.62017771, 8.73129054, 8.84240328, 8.95351325, & 
                     9.06460772                                                              /


  data    l_Colgan / -22.18883401, -21.78629635, -21.60383554, -21.68480662, -21.76444630, &
                     -21.67935529, -21.54217864, -21.37958284, -21.25171892, -21.17584161, &
                     -21.15783402, -21.14491111, -21.13526945, -21.12837453, -21.12485189, &
                     -21.12438898, -21.12641785, -21.12802448, -21.12547760, -21.08964778, &
                     -21.08812360, -21.19542445, -21.34582346, -21.34839251, -21.31700703, &
                     -21.29072156, -21.28900309, -21.34104468, -21.43122351, -21.62448270, &
                     -21.86694036, -22.02897478, -22.08050874, -22.06057061, -22.01973295, &
                     -22.00000434, -22.05161149, -22.22175466, -22.41451671, -22.52581288, &
                     -22.56913516, -22.57485721, -22.56150512, -22.53968863, -22.51490350, &
                     -22.48895932, -22.46071057, -22.42908363, -22.39358639, -22.35456791, &
                     -22.31261375, -22.26827428, -22.22203698, -22.17422996, -22.12514145  /

  contains

    !> Read this module"s parameters from a file
    subroutine rc_params_read(files)
      use mod_global_parameters, only: unitpar
      character(len=*), intent(in) :: files(:)
      integer                      :: n
  
      namelist /rc_list/ coolcurve, coolmethod, ncool, cfrac, tlow, Tfix
  
      do n = 1, size(files)
        open(unitpar, file=trim(files(n)), status="old")
        read(unitpar, rc_list, end=111)
111     close(unitpar)
      end do

    end subroutine rc_params_read

    !> Radiative cooling initialization
    subroutine radiative_cooling_init(phys_gamma,He_abund)
      use mod_global_parameters

      double precision, intent(in) :: phys_gamma,He_abund

      double precision, dimension(:), allocatable :: t_table
      double precision, dimension(:), allocatable :: L_table
      double precision :: ratt, Lerror
      double precision ::fact1, fact2, fact3, dL1, dL2
      double precision :: tstep, Lstep
      integer :: ntable, i, j, ic, nwx,idir
      logical :: jump

      Character(len=65) :: PPL_curves(1:4)
      rc_gamma=phys_gamma
      He_abundance=He_abund
      ncool=4000
      coolcurve='JCcorona'
      coolmethod='exact'
      cfrac=0.1d0
      tlow=bigdouble
      Tfix=.false.
      call rc_params_read(par_files)

      ! Determine flux variables
      nwx = 1                  ! rho (density)

      allocate(mom(ndir))
      do idir = 1, ndir
         nwx    = nwx + 1
         mom(idir) = nwx       ! momentum density
      end do

      nwx = nwx + 1
      e_     = nwx          ! energy density
      eaux_  = iw_eaux
      
      ! Checks if coolcurve is a piecewise power law (PPL)
      PPL_curves = [Character(len=65) :: 'Hildner','FM', 'RP', 'Klimchuk']
      do i=1,size(PPL_curves)
         if (PPL_curves(i)==coolcurve) then
            isPPL = .true.
         end if
      end do

      ! Init for PPL
      if (isPPL) then
         ! Read in tables and create t_PPL, l_PPL, a_PPL
         select case(coolcurve)
         
         case('Hildner')
            if(mype ==0) &
            print *,'Use Hildner (1974) piecewise power law'

            n_PPL = n_Hildner
         
            allocate(t_PPL(1:n_PPL+1), l_PPL(1:n_PPL+1))
            allocate(a_PPL(1:n_PPL))
            
            t_PPL(1:n_PPL+1) = t_Hildner(1:n_Hildner+1)
            a_PPL(1:n_PPL) = a_Hildner(1:n_Hildner)

            l_PPL(1:n_PPL) = 10.d0**x_Hildner(1:n_Hildner) * (10.d0**t_PPL(1:n_PPL))**a_PPL(1:n_PPL)        
            
         case('FM')
            if(mype==0) &
            print *,'Use Forbes and Malherbe (1991)-like piecewise power law'
             
            n_PPL = n_FM
         
            allocate(t_PPL(1:n_PPL+1), l_PPL(1:n_PPL+1))
            allocate(a_PPL(1:n_PPL))
            
            t_PPL(1:n_PPL+1) = t_FM(1:n_FM+1)
            a_PPL(1:n_PPL) = a_FM(1:n_FM)

            l_PPL(1:n_PPL) = 10.d0**x_FM(1:n_FM) * (10.d0**t_PPL(1:n_PPL))**a_PPL(1:n_PPL) 
            
         case('RP')
            if(mype==0) &
            print *,'Use piecewise power law according to Rosner (1978)'
            if(mype ==0) &
            print *,'and extended by Priest (1982) from Van Der Linden (1991)'
             
            n_PPL = n_RP
         
            allocate(t_PPL(1:n_PPL+1), l_PPL(1:n_PPL+1))
            allocate(a_PPL(1:n_PPL))
            
            t_PPL(1:n_PPL+1) = t_RP(1:n_RP+1)
            a_PPL(1:n_PPL) = a_RP(1:n_RP)

            l_PPL(1:n_PPL) = 10.d0**x_RP(1:n_RP) * (10.d0**t_PPL(1:n_PPL))**a_PPL(1:n_PPL)  

         case('Klimchuk')
            if(mype==0) &
            print *,'Use Klimchuk (2008) piecewise power law'
             
            n_PPL = n_Klimchuk
         
            allocate(t_PPL(1:n_PPL+1), l_PPL(1:n_PPL+1))
            allocate(a_PPL(1:n_PPL))
            
            t_PPL(1:n_PPL+1) = t_Klimchuk(1:n_Klimchuk+1)
            a_PPL(1:n_PPL) = a_Klimchuk(1:n_Klimchuk)

            l_PPL(1:n_PPL) = 10.d0**x_Klimchuk(1:n_Klimchuk) * (10.d0**t_PPL(1:n_PPL))**a_PPL(1:n_PPL)  

         case default
            call mpistop("This piecewise power law is unknown")
         end select

         ! Go from logarithmic to actual values.
         t_PPL(1:n_PPL+1) = 10.d0**t_PPL(1:n_PPL+1)
         
         ! Make dimensionless
         t_PPL(1:n_PPL+1) = t_PPL(1:n_PPL+1) / unit_temperature
         l_PPL(1:n_PPL) = l_PPL(1:n_PPL) * unit_numberdensity**2 * unit_time / unit_pressure * (1.d0+2.d0*He_abundance)        

         ! Set tref en lref
         l_PPL(n_PPL+1) = l_PPL(n_PPL) * ( t_PPL(n_PPL+1) / t_PPL(n_PPL) )**a_PPL(n_PPL)
         lref = l_PPL(n_PPL+1)
         tref = t_PPL(n_PPL+1)
         
         ! Set tcoolmin and tcoolmax
         tcoolmin = t_PPL(1)
         tcoolmax = t_PPL(n_PPL+1)
         ! smaller value for lowest temperatures from cooling table and user's choice
         if (tlow==bigdouble) tlow=tcoolmin

         !create y_PPL
         call create_y_PPL()

      else
         ! Init for interpolatable tables
         allocate(tcool(1:ncool), Lcool(1:ncool), dLdtcool(1:ncool))
         allocate(Yc(1:ncool), invYc(1:ncool))

         tcool(1:ncool)    = zero
         Lcool(1:ncool)    = zero
         dLdtcool(1:ncool) = zero
         
         ! Read in the selected cooling curve
         select case(coolcurve)
         
         case('JCcorona')
            if(mype ==0) &
            print *,'Use Colgan & Feldman (2008) cooling curve'
            if(mype ==0) &
            print *,'This version only till 10000 K, beware for floor T treatment'
         
            ntable = n_JCcorona
      
            allocate(t_table(1:ntable))
            allocate(L_table(1:ntable))
            t_table(1:ntable) = t_JCcorona(1:n_JCcorona)
            L_table(1:ntable) = l_JCcorona(1:n_JCcorona)
            
         case('DM')
            if(mype ==0) &
            print *,'Use Dalgarno & McCray (1972) cooling curve'
      
            ntable = n_DM
      
            allocate(t_table(1:ntable))
            allocate(L_table(1:ntable))
            t_table(1:ntable) = t_DM(1:n_DM)
            L_table(1:ntable) = l_DM(1:n_DM)
      
         case('MB')
            if(mype ==0) &
            write(*,'(3a)') 'Use MacDonald & Bailey (1981) cooling curve '&
                 ,'as implemented in ZEUS-3D, with the values '&
                 ,'from Dalgarno & McCRay (1972) for low temperatures.'
         
            ntable = n_MB + 20
      
            allocate(t_table(1:ntable))
            allocate(L_table(1:ntable))
      
            t_table(1:ntable) = t_DM(1:21)
            L_table(1:ntable) = l_DM(1:21)
            t_table(22:ntable) = t_MB(2:n_MB)
            L_table(22:ntable) = l_MB(2:n_MB)
          
         case('MLcosmol')
            if(mype ==0) &
            print *,'Use Mellema & Lundqvist (2002) cooling curve '&
                 ,'for zero metallicity '
      
            ntable = n_MLcosmol
      
            allocate(t_table(1:ntable))
            allocate(L_table(1:ntable))
            t_table(1:ntable) = t_MLcosmol(1:n_MLcosmol)
            L_table(1:ntable) = l_MLcosmol(1:n_MLcosmol)
      
         case('MLwc')
            if(mype ==0) &
            print *,'Use Mellema & Lundqvist (2002) cooling curve '&
                 ,'for WC-star metallicity '
      
            ntable = n_MLwc
      
            allocate(t_table(1:ntable))
            allocate(L_table(1:ntable))
            t_table(1:ntable) = t_MLwc(1:n_MLwc)
            L_table(1:ntable) = l_MLwc(1:n_MLwc)
      
         case('MLsolar1')
            if(mype ==0) &
            print *,'Use Mellema & Lundqvist (2002) cooling curve '&
                 ,'for solar metallicity '
      
            ntable = n_MLsolar1
      
            allocate(t_table(1:ntable))
            allocate(L_table(1:ntable))
            t_table(1:ntable) = t_MLsolar1(1:n_MLsolar1)
            L_table(1:ntable) = l_MLsolar1(1:n_MLsolar1)
      
         case('cloudy_ism')
            if(mype ==0) &
            print *,'Use Cloudy based cooling curve '&
                 ,'for ism metallicity '
      
            ntable = n_cl_ism
      
            allocate(t_table(1:ntable))
            allocate(L_table(1:ntable))
            t_table(1:ntable) = t_cl_ism(1:n_cl_ism)
            L_table(1:ntable) = l_cl_ism(1:n_cl_ism)
      
         case('cloudy_solar')
            if(mype ==0) &
            print *,'Use Cloudy based cooling curve '&
                 ,'for solar metallicity '
      
            ntable = n_cl_solar
      
            allocate(t_table(1:ntable))
            allocate(L_table(1:ntable))
            t_table(1:ntable) = t_cl_solar(1:n_cl_solar)
            L_table(1:ntable) = l_cl_solar(1:n_cl_solar)
      
         case('SPEX')
            if(mype ==0) &
            print *,'Use SPEX cooling curve (Schure et al. 2009) '&
                 ,'for solar metallicity '
      
            ntable = n_SPEX
      
            allocate(t_table(1:ntable))
            allocate(L_table(1:ntable))
            t_table(1:ntable) = t_SPEX(1:n_SPEX)
            L_table(1:ntable) = l_SPEX(1:n_SPEX) + log10(nenh_SPEX(1:n_SPEX))
      
         case('SPEX_DM')
            if(mype ==0) then
               print *, 'Use SPEX cooling curve for solar metallicity above 10^4 K. ' 
               print *, 'At lower temperatures,use Dalgarno & McCray (1972), ' 
               print *, 'with a pre-set ionization fraction of 10^-3. ' 
               print *, 'as described by Schure et al. (2009). '
            endif
         
            ntable = n_SPEX + n_DM_2 - 6
      
            allocate(t_table(1:ntable))
            allocate(L_table(1:ntable))
            t_table(1:n_DM_2-1) = t_DM_2(1:n_DM_2-1)
            L_table(1:n_DM_2-1) = L_DM_2(1:n_DM_2-1)
            t_table(n_DM_2:ntable) = t_SPEX(6:n_SPEX)
            L_table(n_DM_2:ntable) = l_SPEX(6:n_SPEX) + log10(nenh_SPEX(6:n_SPEX))

         case('Dere_corona')
            if(mype ==0) &
            print *,'Use Dere (2009) cooling curve for solar corona'
         
            ntable = n_Dere
      
            allocate(t_table(1:ntable))
            allocate(L_table(1:ntable))
            t_table(1:ntable) = t_Dere(1:n_Dere)
            L_table(1:ntable) = l_Dere_corona(1:n_Dere)

         case('Dere_corona_DM')
            if(mype==0)&
            print *, 'Combination of Dere_corona (2009) for high temperatures and'
            if(mype==0)&
            print *, 'Dalgarno & McCray (1972), DM2, for low temperatures'

            ntable = n_Dere + n_DM_2 - 1 

            allocate(t_table(1:ntable))
            allocate(L_table(1:ntable))
            t_table(1:n_DM_2-1) = t_DM_2(1:n_DM_2-1)
            L_table(1:n_DM_2-1) = L_DM_2(1:n_DM_2-1)
            t_table(n_DM_2:ntable) = t_Dere(1:n_Dere)
            L_table(n_DM_2:ntable) = l_Dere_corona(1:n_Dere)

         case('Dere_photo')
            if(mype ==0) &
            print *,'Use Dere (2009) cooling curve for solar photophere'
         
            ntable = n_Dere
      
            allocate(t_table(1:ntable))
            allocate(L_table(1:ntable))
            t_table(1:ntable) = t_Dere(1:n_Dere)
            L_table(1:ntable) = l_Dere_photo(1:n_Dere)

         case('Dere_photo_DM')
            if(mype==0)&
            print *, 'Combination of Dere_photo (2009) for high temperatures and'
            if(mype==0)&
            print *, 'Dalgarno & McCray (1972), DM2, for low temperatures'

            ntable = n_Dere + n_DM_2 - 1 

            allocate(t_table(1:ntable))
            allocate(L_table(1:ntable))
            t_table(1:n_DM_2-1) = t_DM_2(1:n_DM_2-1)
            L_table(1:n_DM_2-1) = L_DM_2(1:n_DM_2-1)
            t_table(n_DM_2:ntable) = t_Dere(1:n_Dere)
            L_table(n_DM_2:ntable) = l_Dere_photo(1:n_Dere)

         case('Colgan')
            if(mype==0) &
            print *, 'Use Colgan (2008) cooling curve'

            ntable = n_Colgan

            allocate(t_table(1:ntable))
            allocate(L_table(1:ntable))
            t_table(1:ntable) = t_Colgan(1:n_Colgan)
            L_table(1:ntable) = l_Colgan(1:n_Colgan)

         case('Colgan_DM')
            if(mype==0)&
            print *, 'Combination of Colgan (2008) for high temperatures and'
            if(mype==0)&
            print *, 'Dalgarno & McCray (1972), DM2, for low temperatures'

            ntable = n_Colgan + n_DM_2

            allocate(t_table(1:ntable))
            allocate(L_table(1:ntable))
            t_table(1:n_DM_2) = t_DM_2(1:n_DM_2)
            L_table(1:n_DM_2) = L_DM_2(1:n_DM_2)
            t_table(n_DM_2+1:ntable) = t_Colgan(1:n_Colgan)
            L_table(n_DM_2+1:ntable) = l_Colgan(1:n_Colgan)

         case default
            call mpistop("This coolingcurve is unknown")
         end select
      
         ! create cooling table(s) for use in amrvac
         tcoolmax = t_table(ntable)
         tcoolmin = t_table(1)
         ratt     = (tcoolmax-tcoolmin)/( dble(ncool-1) + smalldouble)
         
         tcool(1) = tcoolmin
         Lcool(1) = L_table(1)
         
         tcool(ncool) = tcoolmax
         Lcool(ncool) = L_table(ntable)
         
         do i=2,ncool        ! loop to create one table
           tcool(i) = tcool(i-1)+ratt
           do j=1,ntable-1   ! loop to create one spot on a table
           ! Second order polynomial interpolation, except at the outer edge, 
           ! or in case of a large jump.
             if(tcool(i) < t_table(j+1)) then
                if(j.eq. ntable-1 )then
                  fact1 = (tcool(i)-t_table(j+1))     &
                        /(t_table(j)-t_table(j+1)) 
         
                  fact2 = (tcool(i)-t_table(j))       &
                        /(t_table(j+1)-t_table(j)) 
         
                  Lcool(i) = L_table(j)*fact1 + L_table(j+1)*fact2 
                  exit
                else 
                  dL1 = L_table(j+1)-L_table(j)
                  dL2 = L_table(j+2)-L_table(j+1)
                  jump =(max(dabs(dL1),dabs(dL2)) > 2*min(dabs(dL1),dabs(dL2)))
                endif
                  
                if( jump ) then
                  fact1 = (tcool(i)-t_table(j+1))     &
                        /(t_table(j)-t_table(j+1)) 
         
                  fact2 = (tcool(i)-t_table(j))       &
                        /(t_table(j+1)-t_table(j)) 
                         
                  Lcool(i) = L_table(j)*fact1 + L_table(j+1)*fact2
                  exit          
                else
                  fact1 = ((tcool(i)-t_table(j+1))     &
                        * (tcool(i)-t_table(j+2)))   &
                        / ((t_table(j)-t_table(j+1)) &
                        * (t_table(j)-t_table(j+2)))
      
                  fact2 = ((tcool(i)-t_table(j))       &
                        * (tcool(i)-t_table(j+2)))   &
                        / ((t_table(j+1)-t_table(j)) &
                        * (t_table(j+1)-t_table(j+2)))
      
                  fact3 = ((tcool(i)-t_table(j))       &
                        * (tcool(i)-t_table(j+1)))   &
                        / ((t_table(j+2)-t_table(j)) &
                        * (t_table(j+2)-t_table(j+1)))
         
                  Lcool(i) = L_table(j)*fact1 + L_table(j+1)*fact2 &
                           + L_table(j+2)*fact3
                  exit
                endif
             endif
           enddo  ! end loop to find create one spot on a table
         enddo    ! end loop to create one table
      
         ! Go from logarithmic to actual values.
         tcool(1:ncool) = 10.0D0**tcool(1:ncool)
         Lcool(1:ncool) = 10.0D0**Lcool(1:ncool)
         
         ! Scale both T and Lambda
         tcool(1:ncool) = tcool(1:ncool) / unit_temperature
         Lcool(1:ncool) = Lcool(1:ncool) * unit_numberdensity**2 * unit_time / unit_pressure * (1.d0+2.d0*He_abundance) 
         tcoolmin       = tcool(1)+smalldouble  ! avoid pointless interpolation
         ! smaller value for lowest temperatures from cooling table and user's choice
         if (tlow==bigdouble) tlow=tcoolmin
         tcoolmax       = tcool(ncool)
        
         lgtcoolmin = dlog10(tcoolmin)
         lgtcoolmax = dlog10(tcoolmax)
         lgstep = (lgtcoolmax-lgtcoolmin) * 1.d0 / (ncool-1)
      
         dLdtcool(1)     = (Lcool(2)-Lcool(1))/(tcool(2)-tcool(1))
         dLdtcool(ncool) = (Lcool(ncool)-Lcool(ncool-1))/(tcool(ncool)-tcool(ncool-1))
         
         do i=2,ncool-1
           dLdtcool(i) = (Lcool(i+1)-Lcool(i-1))/(tcool(i+1)-tcool(i-1))
         enddo
      
         deallocate(t_table)
         deallocate(L_table)
      
         if( coolmethod == 'exact' ) then
            tref = tcoolmax
            lref = Lcool(ncool)
            Yc(ncool) = zero
            do i=ncool-1, 1, -1
               Yc(i) = Yc(i+1)
               do j=1,100
                  tstep = 1.0d-2*(tcool(i+1)-tcool(i))
                  call findL(tcool(i+1)-j*tstep, Lstep)
                  Yc(i) = Yc(i) + lref/tref*tstep/Lstep
               enddo
            enddo
         endif
      endif       

    end subroutine radiative_cooling_init

    subroutine create_y_PPL ()
    !  creates the constants of integration needed for solving
    !  the cooling law exact for a piecewise power law 
    !  In correspondence with eq. A6 of Townsend (2009)
 
      use mod_global_parameters

      integer :: i
      double precision :: y_extra, factor
      
      allocate(y_PPL(1:n_PPL+1))

      y_PPL(1:n_PPL+1) = zero

      do i=n_PPL, 1, -1 
          factor = l_PPL(n_PPL+1) * t_PPL(i) / (l_PPL(i) * t_PPL(n_PPL+1))
          if (a_PPL(i) == 1.d0) then 
             y_extra =  log( t_PPL(i) / t_PPL(i+1) )
          else
             y_extra = 1 / (1 - a_PPL(i)) * (1 - ( t_PPL(i) / t_PPL(i+1) )**(a_PPL(i)-1) )
          end if
          y_PPL(i) = y_PPL(i+1) - factor*y_extra
      enddo
 
    end subroutine create_y_PPL



    subroutine cooling_get_dt(w,ixI^L,ixO^L,dtnew,dx^D,x)
      use mod_global_parameters

      integer, intent(in) :: ixI^L, ixO^L
      double precision, intent(in) :: dx^D, x(ixI^S,1:ndim), w(ixI^S,1:nw)
      double precision, intent(inout) :: dtnew
      
      double precision :: etherm(ixI^S)
      double precision :: L1,Tlocal1, ptherm(ixI^S), lum(ixI^S)
      double precision :: plocal, rholocal
      double precision :: Lmax
      integer :: ix^D
      !
      ! Limit timestep to avoid cooling problems when using explicit cooling
      !
      
      if(coolmethod == 'explicit1') then
       call phys_get_pthermal(w,x,ixI^L,ixO^L,ptherm)   
       {do ix^DB = ixO^LIM^DB\}
         plocal   = ptherm(ix^D)
         rholocal = w(ix^D,rho_)
         !  Tlocal = P/rho
         Tlocal1       = max(plocal/(rholocal),smalldouble)
         !  Determine explicit cooling
         !  If temperature is below floor level, no cooling. 
         !  Stop wasting time and go to next gridpoint.
         !  If the temperature is higher than the maximum,
         !  assume Bremsstrahlung
         if( Tlocal1<=tcoolmin ) then
            L1 = zero
         else if( Tlocal1>=tcoolmax )then
            call calc_l_extended(Tlocal1, L1)
            !L1         = Lcool(ncool)*sqrt(Tlocal1/tcoolmax)
            L1         = L1*(rholocal**2)
         else  
            call findL(Tlocal1,L1)
            L1         = L1*(rholocal**2)
         endif
         lum(ix^D) = L1
        {enddo^D&\}
        etherm(ixO^S)=ptherm(ixO^S)/(rc_gamma-1.d0)
        dtnew = cfrac*minval(etherm(ixO^S)/max(lum(ixO^S),smalldouble))
      endif
    
    end subroutine cooling_get_dt

    subroutine getvar_cooling(ixI^L,ixO^L,w,x,coolrate)
    !
    ! Create extra variable to show cooling rate in the output
    ! Uses a simple explicit scheme. 
    ! N.B. Since there is no knowledge of the timestep size, 
    ! there is no upper limit for the cooling rate.
      use mod_global_parameters
      
      integer, intent(in)          :: ixI^L,ixO^L
      double precision, intent(in) :: x(ixI^S,1:ndim)
      double precision             :: w(ixI^S,1:nw)
      double precision, intent(out):: coolrate(ixI^S)
      
      double precision :: etherm(ixI^S)
      double precision :: L1,Tlocal1, ptherm(ixI^S)
      double precision :: plocal, rholocal
      double precision :: emin
      
      integer :: ix^D
      
      call phys_get_pthermal(w,x,ixI^L,ixO^L,ptherm) 
      
      {do ix^DB = ixO^LIM^DB\}
         plocal   = ptherm(ix^D)
         rholocal = w(ix^D,rho_)
         !  Tlocal = P/rho
         Tlocal1       = max(plocal/(rholocal),smalldouble)
         !
         !  Determine explicit cooling
         !
         if( Tlocal1<=tcoolmin ) then
            L1 = zero
         else if( Tlocal1>=tcoolmax )then
            call calc_l_extended(Tlocal1, L1)
            !L1         = Lcool(ncool)*sqrt(Tlocal1/tcoolmax)
            L1         = L1*(rholocal**2)
         else  
            call findL(Tlocal1,L1)
            L1         = L1*(rholocal**2)
         endif
         coolrate(ix^D) = L1
      {enddo^D&\}
    
    end subroutine getvar_cooling
    
    subroutine getvar_cooling_exact(qdt, ixI^L, ixO^L, wCT, w, x, coolrate)
    !
    ! Calculates cooling rate using the exact cooling method,
    ! for usage in eg. source_terms subroutine.
    ! The TEF must be known, so this routine can only be used
    ! together with the "exact" cooling method.
      use mod_global_parameters
    
      integer, intent(in)           :: ixI^L, ixO^L
      double precision, intent(in)  :: qdt, x(ixI^S, 1:ndim), wCT(ixI^S, 1:nw)
      double precision              :: w(ixI^S, 1:nw)
      double precision, intent(out) :: coolrate(ixI^S)
    
      double precision              :: y1, y2, l1, l2, tc
      double precision              :: plocal, rholocal, tlocal1, tlocal2, invgam
      double precision              :: ptherm(ixI^S), pnew(ixI^S)
      double precision              :: emin, Lmax, fact
    
      integer                       :: ix^D
      
      ! Check cooling method
      if( coolmethod /= 'exact') then
         call mpistop("Subroutine getvar_cooling_exact needs the exact cooling method")
      endif
    
      call phys_get_pthermal(wCT, x, ixI^L, ixO^L, ptherm)
      call phys_get_pthermal(w, x, ixI^L, ixO^L, pnew)
    
      fact   = lref*qdt/tref
      invgam = 1.d0/(rc_gamma-1.d0)
    
      {do ix^DB = ixO^LIM^DB\}
         plocal   = ptherm(ix^D)
         rholocal = wCT(ix^D, rho_)
         tlocal1  = max(plocal/rholocal, smalldouble)
       
         emin     = w(ix^D, rho_) * tlow * invgam
         lmax     = max(zero, ( pnew(ix^D)*invgam - emin ) / qdt)
       
         ! No cooling if temperature is below floor level.
         ! Assuming Bremsstrahlung if temperature is higher than maximum.
         if( tlocal1 <= tcoolmin) then
            l1 = zero
         else if( tlocal1 >= tcoolmax ) then
            call calc_l_extended(tlocal1, l1)
            !l1 = lcool(ncool) * sqrt(tlocal1 / tcoolmax)
            l1 = l1 * (rholocal**2)
            l1 = min(l1, lmax)
         else
            call findl(tlocal1, l1)
            call findy(tlocal1, y1)
            tc   = tlocal1 * invgam / (rholocal * l1)
            y2   = y1 + (tlocal1 * fact) / (l1 * tc)
            call findt(tlocal2, y2)
          
            if( tlocal2 <= tcoolmin ) then
               l1 = lmax
            else
               l1 = (tlocal1 - tlocal2) * invgam / (rholocal * qdt)
            endif
            
            l1 = l1 * (rholocal**2)
            l1 = min(l1, lmax)
         endif
         coolrate(ix^D) = l1
      {enddo^D&\}
      
    end subroutine getvar_cooling_exact
    
    subroutine radiative_cooling_add_source(qdt,ixI^L,ixO^L,wCT,w,x,&
         qsourcesplit,active)

    ! w[iw]=w[iw]+qdt*S[wCT,x] where S is the source based on wCT within ixO
      use mod_global_parameters
 
      integer, intent(in) :: ixI^L, ixO^L
      double precision, intent(in) :: qdt, x(ixI^S,1:ndim), wCT(ixI^S,1:nw)
      double precision, intent(inout) :: w(ixI^S,1:nw)
      logical, intent(in) :: qsourcesplit
      logical, intent(inout) :: active

      if(qsourcesplit .eqv. rc_split) then
        active = .true.
        select case(coolmethod)
        case ('explicit1')
          if(mype==0)then
            if(it==1) then
              write(*,*)'Fully explicit cooling is not completely safe in this version'
              write(*,*)'PROCEED WITH CAUTION!'
            endif
          endif
          call cool_explicit1(qdt,ixI^L,ixO^L,wCT,w,x)
        case ('explicit2')
          call cool_explicit2(qdt,ixI^L,ixO^L,wCT,w,x)
        case ('semiimplicit')
          call cool_semiimplicit(qdt,ixI^L,ixO^L,wCT,w,x)
        case ('implicit')   
          call cool_implicit(qdt,ixI^L,ixO^L,wCT,w,x)   
        case ('exact')   
          call cool_exact(qdt,ixI^L,ixO^L,wCT,w,x)
        case default
          call mpistop("This cooling method is unknown")
        end select
        if( Tfix ) call floortemperature(qdt,ixI^L,ixO^L,wCT,w,x)
      end if

    end subroutine radiative_cooling_add_source

    subroutine floortemperature(qdt,ixI^L,ixO^L,wCT,w,x)
    !  Force minimum temperature to a fixed temperature
      use mod_global_parameters

      integer, intent(in)             :: ixI^L, ixO^L
      double precision, intent(in)    :: qdt, x(ixI^S,1:ndim), wCT(ixI^S,1:nw)
      double precision, intent(inout) :: w(ixI^S,1:nw)
      
      double precision :: etherm(ixI^S), emin, tfloor
      integer :: ix^D

      tfloor = tlow

      call phys_get_pthermal(w,x,ixI^L,ixO^L,etherm)  
      
      {do ix^DB = ixO^LIM^DB\}
         emin         = w(ix^D,rho_)*tfloor/(rc_gamma-1.d0)
         etherm(ix^D) = etherm(ix^D)/(rc_gamma-1.d0)
         if( etherm(ix^D) < emin ) w(ix^D,e_)=w(ix^D,e_)-etherm(ix^D)+emin
      {enddo^D&\}

    end subroutine floortemperature

    subroutine cool_explicit1(qdt,ixI^L,ixO^L,wCT,w,x)
    ! explicit cooling routine that depends on getdt to 
    ! adjust the timestep. Accurate but incredibly slow
      use mod_global_parameters

      integer, intent(in)             :: ixI^L, ixO^L
      double precision, intent(in)    :: qdt, x(ixI^S,1:ndim), wCT(ixI^S,1:nw)
      double precision, intent(inout) :: w(ixI^S,1:nw)
      
      double precision :: L1,Tlocal1, ptherm(ixI^S),pnew(ixI^S)
      double precision :: plocal, rholocal
      double precision :: emin, Lmax
      
      integer :: ix^D
      integer :: icool
      
      call phys_get_pthermal(wCT,x,ixI^L,ixO^L,ptherm)     
      call phys_get_pthermal(w,x,ixI^L,ixO^L,pnew)

      {do ix^DB = ixO^LIM^DB\}
         plocal   = ptherm(ix^D)
         rholocal = wCT(ix^D,rho_)
         emin     = rholocal*tlow/(rc_gamma-1.d0)
         Lmax            = max(zero,pnew(ix^D)/(rc_gamma-1.d0)-emin)/qdt
         !  Tlocal = P/rho
         Tlocal1       = max(plocal/(rholocal),smalldouble)
         !
         !  Determine explicit cooling
         !
         !  If temperature is below floor level, no cooling. 
         !  Stop wasting time and go to next gridpoint.
         !  If the temperature is higher than the maximum,
         !  assume Bremsstrahlung
         if( Tlocal1<=tcoolmin ) then
            L1 = zero
         else if( Tlocal1>=tcoolmax )then
            call calc_l_extended(Tlocal1, L1)
            !L1         = Lcool(ncool)*sqrt(Tlocal1/tcoolmax)
            L1         = L1*(rholocal**2)
            if(trac .and. Tlocal1 .lt. block%special_values(1)) then
              L1=L1*sqrt((Tlocal1/block%special_values(1))**5)
            end if
            L1         = min(L1,Lmax)
            w(ix^D,e_) = w(ix^D,e_)-L1*qdt
            if(phys_solve_eaux) w(ix^D,eaux_)=w(ix^D,eaux_)-L1*qdt 
         else  
            call findL(Tlocal1,L1)
            L1         = L1*(rholocal**2)
            if(trac .and. Tlocal1 .lt. block%special_values(1)) then
              L1=L1*sqrt((Tlocal1/block%special_values(1))**5)
            end if
            L1         = min(L1,Lmax)
            w(ix^D,e_) = w(ix^D,e_)-L1*qdt
            if(phys_solve_eaux) w(ix^D,eaux_)=w(ix^D,eaux_)-L1*qdt 
         endif
      {enddo^D&\}
      
    end subroutine cool_explicit1

    subroutine cool_explicit2(qdt,ixI^L,ixO^L,wCT,w,x)
    !
    ! explicit cooling routine that does a series 
    ! of small forward integration steps, to make 
    ! sure the amount of cooling remains correct
    !
    ! Not as accurate as 'explicit1', but a lot faster
    ! tends to overestimate cooling
    
      use mod_global_parameters
      
      integer, intent(in)             :: ixI^L, ixO^L
      double precision, intent(in)    :: qdt, x(ixI^S,1:ndim), wCT(ixI^S,1:nw)
      double precision, intent(inout) :: w(ixI^S,1:nw)
      
      double precision :: Ltest, etherm, de
      double precision :: dtmax, dtstep
      
      integer :: idt,ndtstep
      
      double precision :: L1,Tlocal1,ptherm(ixI^S),pnew(ixI^S)
      double precision :: plocal, rholocal
      double precision :: emin, Lmax
      
      integer :: ix^D
      integer :: icool

      call phys_get_pthermal(wCT,x,ixI^L,ixO^L,ptherm) 
      call phys_get_pthermal(w,x,ixI^L,ixO^L,pnew ) 

      {do ix^DB = ixO^LIM^DB\}
         !  Calculate explicit cooling value
         dtmax    = qdt
         plocal   = ptherm(ix^D)
         etherm   = plocal/(rc_gamma-1.d0)
      
         rholocal = wCT(ix^D,rho_)
         emin     = rholocal*tlow/(rc_gamma-1.d0)
         Lmax            = max(zero,(pnew(ix^D)/(rc_gamma-1.d0))-emin)/qdt
         !  Tlocal = P/rho
         Tlocal1       = plocal/(rholocal)
         !
         !  Determine explicit cooling
         !
         !  If temperature is below floor level, no cooling. 
         !  Stop wasting time and go to next gridpoint.
         !  If the temperature is higher than the maximum,
         !  assume Bremmstrahlung
         if( Tlocal1<=tcoolmin ) then
            Ltest = zero
         else if( Tlocal1>=tcoolmax )then
            call calc_l_extended(Tlocal1, Ltest)
            !Ltest = Lcool(ncool)*sqrt(Tlocal1/tcoolmax)
            Ltest = L1*(rholocal**2)
            if(trac .and. Tlocal1 .lt. block%special_values(1)) then
              Ltest=Ltest*sqrt((Tlocal1/block%special_values(1))**5)
            end if
            Ltest = min(L1,Lmax)
            if( dtmax>cfrac*etherm/Ltest) dtmax = cfrac*etherm/Ltest
         else  
            call findL(Tlocal1,Ltest)
            Ltest = Ltest*(rholocal**2)
            if(trac .and. Tlocal1 .lt. block%special_values(1)) then
              Ltest=Ltest*sqrt((Tlocal1/block%special_values(1))**5)
            end if
            Ltest = min(Ltest,Lmax)
            if( dtmax>cfrac*etherm/Ltest) dtmax = cfrac*etherm/Ltest
         endif
         !
         !  Calculate number of steps for cooling
         !
         ndtstep = max(nint(qdt/dtmax),1)+1
         dtstep = qdt/ndtstep
         !
         !  Use explicit cooling value for first step
         !
         de     = Ltest*dtstep
         etherm = etherm - de
         
         do idt=2,ndtstep
            plocal = etherm*(rc_gamma-1.d0)
            Lmax   = max(zero,etherm-emin)/dtstep
            !  Tlocal = P/rho
            Tlocal1 = plocal/(rholocal)
            if( Tlocal1<=tcoolmin ) then
               L1 = zero
               exit
            else if( Tlocal1>=tcoolmax )then
              call calc_l_extended(Tlocal1, L1)
              !L1 = Lcool(ncool)*sqrt(Tlocal1/tcoolmax)
              L1 = L1*(rholocal**2)
              if(trac .and. Tlocal1 .lt. block%special_values(1)) then
                L1=L1*sqrt((Tlocal1/block%special_values(1))**5)
              end if
              L1 = min(L1,Lmax)
            else  
              call findL(Tlocal1,L1)
              L1 = L1*(rholocal**2)
              if(trac .and. Tlocal1 .lt. block%special_values(1)) then
                L1=L1*sqrt((Tlocal1/block%special_values(1))**5)
              end if
              L1 = min(L1,Lmax)
            end if
            
            de     = de + L1*dtstep
            etherm = etherm - L1*dtstep
         enddo
         w(ix^D,e_) = w(ix^D,e_) -de 
         if(phys_solve_eaux) w(ix^D,eaux_)=w(ix^D,eaux_)-de
      {enddo^D&\}
      
    end subroutine cool_explicit2

    subroutine cool_semiimplicit(qdt,ixI^L,ixO^L,wCT,w,x)
    !
    ! Semi-implicit cooling method based on a two point 
    ! average
    !
    ! Fast, but tends to underestimate cooling
      use mod_global_parameters
      
      integer, intent(in)             :: ixI^L, ixO^L
      double precision, intent(in)    :: qdt, x(ixI^S,1:ndim), wCT(ixI^S,1:nw)
      double precision, intent(inout) :: w(ixI^S,1:nw)
      
      double precision :: L1,L2,Tlocal1, Tlocal2
      double precision :: etemp
      
      double precision :: plocal, rholocal
      double precision :: emin, Lmax
      
      double precision :: ptherm(ixI^S),pnew(ixI^S)
      integer :: ix^D

      call phys_get_pthermal(wCT,x,ixI^L,ixO^L,ptherm)   
      call phys_get_pthermal(w,x,ixI^L,ixO^L,pnew )  

      {do ix^DB = ixO^LIM^DB\}
         plocal   = ptherm(ix^D)
         rholocal = wCT(ix^D,rho_)
         emin     = rholocal*tlow/(rc_gamma-1.d0)
         Lmax            = max(zero,pnew(ix^D)/(rc_gamma-1.d0)-emin)/qdt
         !  Tlocal = P/rho
         Tlocal1       = max(plocal/(rholocal),smalldouble)
         !
         !  Determine explicit cooling at present temperature
         !
         !  If temperature is below floor level, no cooling. 
         !  Stop wasting time and go to next gridpoint.
         !  If the temperature is higher than the maximum,
         !  assume Bremsstrahlung
         if( Tlocal1<=tcoolmin ) then
            L1 = zero
            L2 = zero
         else
           if( Tlocal1>=tcoolmax )then
              call calc_l_extended(Tlocal1, L1)
              !L1 = Lcool(ncool)*sqrt(Tlocal1/tcoolmax)
           else  
              call findL(Tlocal1,L1)            
           end if                       
           L1      = L1*(rholocal**2)
           etemp   = plocal/(rc_gamma-1.d0) - L1*qdt
            if(trac .and. Tlocal1 .lt. block%special_values(1)) then
              L1=L1*sqrt((Tlocal1/block%special_values(1))**5)
            end if
           Tlocal2 = etemp*(rc_gamma-1.d0)/(rholocal)
           !
           !  Determine explicit cooling at new temperature
           !
           if( Tlocal2<=tcoolmin ) then
              L2 = zero
           else if( Tlocal2>=tcoolmax )then
              call calc_l_extended(Tlocal2, L2)
              !L2 = Lcool(ncool)*sqrt(Tlocal2/tcoolmax)
           else
              call findL(Tlocal2,L2)
           end if
           L2  = L2*(rholocal**2)
            if(trac .and. Tlocal2 .lt. block%special_values(1)) then
              L2=L2*sqrt((Tlocal2/block%special_values(1))**5)
            end if
           w(ix^D,e_) = w(ix^D,e_) - min(half*(L1+L2),Lmax)*qdt
           if(phys_solve_eaux) &
             w(ix^D,eaux_)=w(ix^D,eaux_)-min(half*(L1+L2),Lmax)*qdt
         endif 
      {enddo^D&\}
      
    end subroutine cool_semiimplicit

    subroutine cool_implicit(qdt,ixI^L,ixO^L,wCT,w,x)
    !
    ! Implicit cooling method based on a half-step
    ! refinement algorithm
    !
      use mod_global_parameters
      
      integer, intent(in)             :: ixI^L, ixO^L
      double precision, intent(in)    :: qdt, x(ixI^S,1:ndim), wCT(ixI^S,1:nw)
      double precision, intent(inout) :: w(ixI^S,1:nw)
      
      double precision :: Ltemp,Tlocal1,Tnew,f1,f2,ptherm(ixI^S), pnew(ixI^S)
      
      double precision :: plocal, rholocal, elocal
      double precision :: emin, Lmax, eold, enew, estep
      integer, parameter :: maxiter = 100
      double precision, parameter :: e_error = 1.0D-6
      
      integer :: ix^D, j

      call phys_get_pthermal(wCT,x,ixI^L,ixO^L,ptherm)   
      call phys_get_pthermal(w,x,ixI^L,ixO^L,pnew )  

      {do ix^DB = ixO^LIM^DB\}
         plocal   = ptherm(ix^D)  
         elocal   = plocal/(rc_gamma-1.d0)
         rholocal = wCT(ix^D,rho_)
         emin     = rholocal*tlow/(rc_gamma-1.d0)
         Lmax            = max(zero,pnew(ix^D)/(rc_gamma-1.d0)-emin)/qdt
         !  Tlocal = P/rho
         Tlocal1       = max(plocal/(rholocal),smalldouble)
         !
         !  Determine explicit cooling at present temperature
         !
         !  If temperature is below floor level, no cooling. 
         !  Stop wasting time and go to next gridpoint.
         !  If the temperature is higher than the maximum,
         !  assume Bremsstrahlung
         if( Tlocal1<=tcoolmin ) then
            Ltemp = zero
         else
           eold  = elocal
           enew  = elocal
           estep = -(smalldouble)
           f2    = 1.d0
           do j=1,maxiter+1
             if( j>maxiter ) call mpistop("Implicit cooling exceeds maximum iterations")
             Tnew  = enew*(rc_gamma-1.d0)/(rholocal)   
             if( Tnew<=tcoolmin ) then
               Ltemp = Lmax
               exit
             else if( Tnew>=tcoolmax )then
               call calc_l_extended(Tnew, Ltemp)
               !Ltemp = Lcool(ncool)*sqrt(Tnew/tcoolmax)
             else  
               call findL(Tnew,Ltemp)
             end if
             Ltemp = Ltemp*(rholocal**2)
            
             eold  = enew + Ltemp*qdt
      
             f1 = elocal -eold
             if( abs(half*f1/(elocal+eold)) < e_error  ) exit 
             if(trac .and. Tnew .lt. block%special_values(1)) then
               Ltemp=Ltemp*sqrt((Tnew/block%special_values(1))**5)
             end if
      
             if(j==1) estep = max((elocal-emin)*half,smalldouble)
             if(f1*f2 < zero ) estep = -half*estep   
             f2 = f1
             enew = enew +estep
           enddo
         endif     
         w(ix^D,e_)     = w(ix^D,e_) - min(Ltemp,Lmax)*qdt
         if(phys_solve_eaux) w(ix^D,eaux_)=w(ix^D,eaux_)-min(Ltemp,Lmax)*qdt
      {enddo^D&\}
       
    end subroutine cool_implicit

    subroutine cool_exact(qdt,ixI^L,ixO^L,wCT,w,x)
    !
    !  Cooling routine using exact integration method from Townsend 2009
    !
      use mod_global_parameters
      
      integer, intent(in)             :: ixI^L, ixO^L
      double precision, intent(in)    :: qdt, x(ixI^S,1:ndim), wCT(ixI^S,1:nw)
      double precision, intent(inout) :: w(ixI^S,1:nw)
      
      double precision :: Y1, tc, Y2
      double precision :: L1,Tlocal1, ptherm(ixI^S), Tlocal2, pnew(ixI^S)
      double precision :: plocal, rholocal, invgam
      double precision :: emin, Lmax, fact
      
      integer :: ix^D
      integer :: icool

      call phys_get_pthermal(wCT,x,ixI^L,ixO^L,ptherm)  
      call phys_get_pthermal(w,x,ixI^L,ixO^L,pnew )  

      fact = lref*qdt/tref

      invgam=1.d0/(rc_gamma-1.d0)
      {do ix^DB = ixO^LIM^DB\}
         plocal   = ptherm(ix^D)
         rholocal = wCT(ix^D,rho_)
         emin     = w(ix^D,rho_)*tlow*invgam
         Lmax            = max(zero,(pnew(ix^D)*invgam-emin)/qdt)
         !  Tlocal = P/rho
         Tlocal1   = max(plocal/rholocal,smalldouble)
         !
         !  Determine explicit cooling
         !
         !  If temperature is below floor level, no cooling. 
         !  Stop wasting time and go to next gridpoint.
         !  If the temperature is higher than the maximum,
         !  assume Bremsstrahlung
         if( Tlocal1<=tcoolmin ) then
            L1 = zero
         else if( Tlocal1>=tcoolmax )then
            call calc_l_extended(Tlocal1, L1)
            !L1         = Lcool(ncool)*sqrt(Tlocal1/tcoolmax)
            L1         = L1*(rholocal**2)
            if(trac .and. Tlocal1 .lt. block%special_values(1)) then
              L1=L1*sqrt((Tlocal1/block%special_values(1))**5)
            end if
            L1         = min(L1,Lmax)
            w(ix^D,e_) = w(ix^D,e_)-L1*qdt
            if(phys_solve_eaux) w(ix^D,eaux_)=w(ix^D,eaux_)-L1*qdt
         else  
            call findL(Tlocal1,L1)
            call findY(Tlocal1,Y1)
            tc         = Tlocal1*invgam/(rholocal*L1)
            Y2         = Y1+(Tlocal1*fact)/(L1*tc)
            call findT(Tlocal2,Y2)
            if(Tlocal2<=tcoolmin) then
              L1 = Lmax
            else
              L1 = (Tlocal1-Tlocal2)*invgam/(rholocal*qdt)
            endif
            L1          = L1*(rholocal**2)
            if(trac .and. Tlocal1 .lt. block%special_values(1)) then
              L1=L1*sqrt((Tlocal1/block%special_values(1))**5)
            end if
            L1          = min(L1,Lmax)   
            w(ix^D,e_)  = w(ix^D,e_)-L1*qdt
            if(phys_solve_eaux) w(ix^D,eaux_)=w(ix^D,eaux_)-L1*qdt
         endif
      {enddo^D&\}

    end subroutine cool_exact

    subroutine calc_l_extended (tpoint, lpoint)
    !  Calculate l for t beyond tcoolmax
    !  Assumes Bremsstrahlung for the interpolated tables
    !  Uses the power law for piecewise power laws
      double precision, intent(IN)  :: tpoint
      double precision, intent(OUT) :: lpoint       
   
      if (isPPL) then
         lpoint = l_PPL(n_PPL) * ( tpoint / t_PPL(n_PPL) )**a_PPL(n_PPL) 
      else
         lpoint = Lcool(ncool) * sqrt( tpoint / tcoolmax)
      end if

    end subroutine calc_l_extended


    subroutine findL (tpoint,Lpoint)
    !  Fast search option to find correct point 
    !  in cooling curve
      use mod_global_parameters
      
      double precision,intent(IN)   :: tpoint
      double precision, intent(OUT) :: Lpoint
      integer :: ipoint
      integer :: jl,jc,jh
      double precision :: lgtp
 
      integer :: i

      if (isPPL) then
         i = maxloc(t_PPL, dim=1, mask=t_PPL<tpoint)
         Lpoint = l_PPL(i) * (tpoint / t_PPL(i))**a_PPL(i)
      else
         lgtp = dlog10(tpoint)
         jl = int((lgtp - lgtcoolmin) / lgstep) + 1
         Lpoint = Lcool(jl)+ (tpoint-tcool(jl)) &
                   * (Lcool(jl+1)-Lcool(jl)) &
                   / (tcool(jl+1)-tcool(jl))
      end if

!      if (tpoint == tcoolmin) then
!        Lpoint = Lcool(1)
!      else if (tpoint == tcoolmax) then
!        Lpoint = Lcool(ncool)
!      else
!        jl=0
!        jh=ncool+1  
!        do
!          if (jh-jl <= 1) exit
!          jc=(jh+jl)/2
!          if (tpoint >= tcool(jc)) then
!              jl=jc
!          else
!              jh=jc
!          end if
!        end do
!        ! Linear interpolation to obtain correct cooling
!        Lpoint = Lcool(jl)+ (tpoint-tcool(jl)) &
!                  * (Lcool(jl+1)-Lcool(jl)) &
!                  / (tcool(jl+1)-tcool(jl))
!      end if
    
    end subroutine findL

    subroutine findY (tpoint,Ypoint)
    
    !  Fast search option to find correct point in cooling time (TEF)
    
      use mod_global_parameters
      
      double precision,intent(IN)   :: tpoint
      double precision, intent(OUT) :: Ypoint
      integer :: ipoint
      integer :: jl,jc,jh
      double precision :: lgtp

      integer :: i
      double precision :: y_extra,factor

      if (isPPL) then
         i = maxloc(t_PPL, dim=1, mask=t_PPL<tpoint)
         factor = l_PPL(n_PPL+1) * t_PPL(i) / (l_PPL(i) * t_PPL(n_PPL+1))
         if (a_PPL(i)==1.d0) then
            y_extra = log( t_PPL(i) / tpoint )
         else
            y_extra = 1 / (1 - a_PPL(i)) * (1 - ( t_PPL(i) / tpoint )**(a_PPL(i)-1) )
         end if
         Ypoint = y_PPL(i) + factor*y_extra
      else
         lgtp = dlog10(tpoint)
         jl = int((lgtp - lgtcoolmin) / lgstep) + 1
         Ypoint = Yc(jl)+ (tpoint-tcool(jl)) &
                   * (Yc(jl+1)-Yc(jl)) &
                   / (tcool(jl+1)-tcool(jl))
      end if

  !    integer i
  !    
  !    if (tpoint == tcoolmin) then
  !      Ypoint = Yc(1)
  !    else if (tpoint == tcoolmax) then
  !      Ypoint = Yc(ncool)
  !    else
  !      jl=0
  !      jh=ncool+1  
  !      do
  !        if (jh-jl <= 1) exit
  !        jc=(jh+jl)/2
  !        if (tpoint >= tcool(jc)) then
  !           jl=jc
  !        else
  !           jh=jc
  !        end if
  !      end do
  !      ! Linear interpolation to obtain correct value
  !      Ypoint = Yc(jl)+ (tpoint-tcool(jl)) &
  !                * (Yc(jl+1)-Yc(jl)) &
  !                / (tcool(jl+1)-tcool(jl))
  !    end if
    
    end subroutine findY

    subroutine findT (tpoint,Ypoint)
    
    !  Fast search option to find correct temperature 
    !  from temporal evolution function. Only possible this way because T is a monotonously 
    !  decreasing function for the interpolated tables 
    !  Uses eq. A7 from Townsend 2009 for piecewise power laws
      use mod_global_parameters
      
      double precision,intent(OUT)   :: tpoint
      double precision, intent(IN) :: Ypoint
      integer :: ipoint
      integer :: jl,jc,jh
      
      integer :: i
      double precision :: factor
      
      if (isPPL) then
         i = minloc(y_PPL, dim=1, mask=y_PPL>Ypoint)
         factor =  l_PPL(i) * t_PPL(n_PPL+1) / (l_PPL(n_PPL+1) * t_PPL(i))
         if (a_PPL(i)==1.d0) then
            tpoint = t_PPL(i) * exp( -1.d0 * factor * ( Ypoint - y_PPL(i)))
         else
            tpoint = t_PPL(i) * (1 - (1 - a_PPL(i)) * factor * (Ypoint - y_PPL(i)))**(1 / (1 - a_PPL(i)))
         end if
      else
         if (Ypoint >= Yc(1)) then
            tpoint = tcoolmin
         else if (Ypoint == Yc(ncool)) then
            tpoint = tcoolmax
         else
            jl=0
            jh=ncool+1
            do
               if (jh-jl <= 1) exit
               jc=(jh+jl)/2
               if (Ypoint <= Yc(jc)) then
                  jl=jc
               else
                  jh=jc
               end if
            end do
            ! Linear interpolation to obtain correct temperature
            tpoint = tcool(jl)+ (Ypoint-Yc(jl)) &
                   * (tcool(jl+1)-tcool(jl)) &
                   / (Yc(jl+1)-Yc(jl))
         end if
      end if

    end subroutine findT


    subroutine finddLdt (tpoint,dLpoint)
    
    !  Fast search option to find correct point 
    !  in derivative of cooling curve
    !  Does not work for the piecewise power laws
      use mod_global_parameters
      
      double precision,intent(IN)   :: tpoint
      double precision, intent(OUT) :: dLpoint
      integer :: ipoint
      integer :: jl,jc,jh
      double precision :: lgtp

      lgtp = dlog10(tpoint)
      jl = int((lgtp - lgtcoolmin) / lgstep) + 1
      dLpoint = dLdtcool(jl)+ (tpoint-tcool(jl)) &
                * (dLdtcool(jl+1)-dLdtcool(jl)) &
                / (tcool(jl+1)-tcool(jl))

!      if (tpoint == tcoolmin) then
!        dLpoint = dLdtcool(1)
!      else if (tpoint == tcoolmax) then
!        dLpoint = dLdtcool(ncool)
!      else
!        jl=0
!        jh=ncool+1  
!        do
!          if (jh-jl <= 1) exit
!          jc=(jh+jl)/2
!          if (tpoint >= tcool(jc)) then
!              jl=jc
!          else
!              jh=jc
!          end if
!        end do
!        ! Linear interpolation to obtain correct cooling derivative
!        dLpoint = dLdtcool(jl)+ (tpoint-tcool(jl)) &
!                  * (dLdtcool(jl+1)-dLdtcool(jl)) &
!                  / (tcool(jl+1)-tcool(jl))
!      end if
    end subroutine finddLdt

end module mod_radiative_cooling
