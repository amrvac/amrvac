<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MPI-AMRVAC: Data file conversion</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="my_customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MPI-AMRVAC<span id="projectnumber">&#160;3.1</span>
   </div>
   <div id="projectbrief">The MPI - Adaptive Mesh Refinement - Versatile Advection Code</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Data file conversion</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="convert_intro"></a>
Introduction</h1>
<p>The standard <a class="el" href="md_doc_2fileformat.html">MPI-AMRVAC dataformat</a>, i.e. the <em>*.dat</em> files usable for restart, contain all the conservative variables in all gridblocks, and hence suffice for visualization. Additional variables can be added in the <em>*.dat</em> files as explained <a class="el" href="md_doc_2dat__convert.html">here</a>. <br  />
 </p><blockquote class="doxtable">
<p>&zwj;Since late 2019, it can be directly read, visualised and analysed with the Python package <a href="https://yt-project.org">yt</a>, see <a class="el" href="md_doc_2yt__usage.html">our documentation to get started with yt</a>. </p>
</blockquote>
<p>However, in many instances, one would like to use data formats that are directly readable by some of the more widespread visualization software packages. Therefore, we created the <em>convert.t</em> module, which ensures that this post-process data file conversion can be done with the same executable (but possibly even on a different platform). The many possibilities include conversion to <em>*.vtu</em> (<em>VTK</em> <em>U*nstructured data format) directly readable by <a href="http://www.paraview.org/">Paraview</a> (or <a href="https://wci.llnl.gov/codes/visit/">ViSiT</a>), to _</em>.plt_ format for the commercial package <a href="http://www.tecplot.com/">Tecplot</a>. Also, <b>this info will not explain you how to use the mentioned software for visualization, but just explain how to do the conversion.</b> Furthermore, this part of the code is subject to continuous change and improvement, and we welcome extra contributions.</p>
<p>We now give some brief info on how to use the same executable <em>amrvac</em> (which you already compiled and used to obtain output <em>*.dat</em> files with), to convert a single or all <em>*.dat</em> file(s) to one of these formats.</p>
<h1><a class="anchor" id="converting"></a>
Converting (on a single CPU)</h1>
<p>** Note that all the steps below assume you're running on a single CPU. The same steps are to be taken for obtaining any of the other precoded data formats. One important warning is due: when you run a simulation for some reason twice, and you did not erase the previously created <em>*.dat</em> files, these files are overwritten (if the base_filename has not changed). Then, it may be that conversion fails, since the end of the file may contain some leftover data from the previous time, if the filelength has changed due to some other reason. The only remedy to this is that one should always remove old <em>*.dat</em> files, or never forget to change the name for the files accordingly, by setting <em>base_filename</em> in the <em>&amp;filelist;</em>.**</p>
<p>We will assume that you ran the standard 2D advection problem used for test purposes, i.e. that you did the following steps beforehand: </p><pre class="fragment">cd $AMRVAC_DIR/tests/rho/vac
$AMRVAC_DIR/setup.pl -d=2
make
mpirun -np 1 amrvac
</pre><p> We also assume that in the parameter file amrvac.par, the namelist <em>&amp;filelist;</em> was stating (note that the end of the namelist is indicated as usual by a backslash) </p><pre class="fragment"> &amp;filelist
        base_filename='vaclogo'
 /
</pre><p> If all went well, you then have created as many <em>*.dat</em> files as requested through the settings you provided in the combined <em>&amp;savelist;</em> and <em>&amp;stoplist;</em> namelists from the <a class="el" href="md_doc_2par.html">par-file</a>. For the example, they normally default to asking a full data dump at time zero, as well as every time the time has increased by 0.05, and this till <em>tmax=1.0d0</em>, such that we actually have 21 snapshots in total. You should thus have files like <em>vaclogo0000.dat</em> up to <em>vaclogo0020.dat</em>. You can now individually convert such <em>*.dat</em> file to a <em>*.vtu</em> file by doing the following. Edit the amrvac.par file, to select a visualization data format like </p><pre class="fragment"> &amp;filelist
        base_filename='vaclogo'
        convert_type='vtuBCC'
        convert=.true.
        restart_from_file='vaclogo0000.dat'
 /
</pre><p> you can then convert the single <em>vaclogo0000.dat</em> file simply running again </p><pre class="fragment">mpirun -np 1 amrvac
</pre><p> or, which is actually equivalent (single CPU) </p><pre class="fragment">amrvac
</pre><p> Note that this will create a new file, namely <em>vaclogo0000.vtu</em>, which can be directly imported in Paraview. It will, under the settings above, just contain the density on the grid hierarchy at time zero. The <em>convert_type='vtuBCC'</em> indicates that the data is exactly as the code interprets and updates the values, namely as cell-centered quantities.</p>
<p>Realizing that you typically want to convert multiple data files, you can do this by repeating the above as many times as there are <em>*.dat</em> files, by raising/changing the <em>restart_from_file</em> identifier. Since you typically want to convert all data files between a minimum and maximum number of similarly named files, the script <b>aiconvert</b> is added. If you have a line <code>PATH="$AMRVAC_DIR:$AMRVAC_DIR/tools:./:$PATH"</code> in <code>~/.bash_profile</code> (or <code>~/.bashrc</code>), typing <em>aiconvert</em> will tell you its intended usage. In the example case at hand, where we created 21 data files from running the advection problem, <b>this <em>aiconvert</em> script needs the intended <em>base_filename</em> and the executable <em>amrvac</em> to exist in the same directory.</b> It will complain when the parfile does not exist, and obviously requires the existence of all files between the start and stopindex (0 and 20 here). With paraview, you will then be able to immediately import all 21 <em>*.vtu</em> files with the same base filename, and directly make movies or still images from them.</p>
<p>For example, to convert snapshots from number 10 to number 20: </p><pre class="fragment">aiconvert 10 20
</pre><p> or to convert the snapshot number 12 </p><pre class="fragment">aiconvert 12
</pre><p> or just type </p><pre class="fragment">aiconvert
</pre><p> to convert all the snapshots! You can also specify a parfile other than amrvac.par as: </p><pre class="fragment">aiconvert newname.par 0 20
</pre><p> or to convert the snapshot number 12 </p><pre class="fragment">aiconvert newname.par 12
</pre><p> For details of aiconvert, please read the header of the $AMRVAC_DIR/tools/aiconvert.</p>
<h1><a class="anchor" id="parallel_convert"></a>
Parallel conversion options</h1>
<p>For very large simulations (typically 3D, and/or runs achieving high effective resolutions), even the data conversion may need to be done in parallel (and ultimately, the visualization itself too). The <em>convert.t</em> allows to perform some of the <em>*.dat</em> conversions in parallel, in particular, this is true for the <em>*.vtu</em> format, and for the <em>*.plt</em> format. You should then select one of </p><pre class="fragment">convert_type='vtumpi'
convert_type='vtuCCmpi'
convert_type='vtuBmpi'
convert_type='vtuBCCmpi'
convert_type='vtimpi'
convert_type='vtiCCmpi'
convert_type='pvtumpi'
convert_type='pvtuCCmpi'
convert_type='pvtuBmpi'
convert_type='pvtuBCCmpi'
convert_type='tecplotmpi'
convert_type='tecplotCCmpi'
</pre><p> Here, the prefix <em>p</em> stands for the parallel file format, where each process is allowed to dump its data into a single (e.g. <em>*.vtu</em>) file and a master file (e.g. <em>*.pvtu</em>) is stored by rank zero. This has the advantage that the write operation on suitable file systems is sped up significantly. In a visualization software, only the <em>*.pvtu</em> files need to be imported and also the reading process is sped up in case of parallel visualization.</p>
<p>You can again use aiconvert as explained above, and type in the number of processors to use by answering a popup question: </p><pre class="fragment">How many processors do you want to use? (default=1) 4
</pre> <h1><a class="anchor" id="autoconvert"></a>
Autoconvert</h1>
<p>In addition to the conversion after the run, AMRVAC now offers also to directly output files ready to use for visualization along with the simulation. A parallel run will however only be capable to provide the file- types ready for parallel conversion (see parallel conversion). To enable this capability, simply set the switch <em>autoconvert=.true.</em>. The example above would then read </p><pre class="fragment">&amp;filelist;
        base_filename='vaclogo'
        autoconvert=.true.
        convert_type='vtuBCCmpi'
 /
</pre><p> and when the code is run via </p><pre class="fragment">mpirun -np 2 amrvac
</pre><p> three new output files (<em>vaclogoXXXX0000.vtu, vaclogoXXXX0001.vtu</em>) will appear simultaneous to the <em>vaclogoXXXX.dat</em> files, stored at given intervals. All functionality of the usual convert is conserved, e.g. derived quantities and primitive variables (using the <em>saveprim=.true.</em> option) can be stored in the output files.</p>
<h1><a class="anchor" id="notes"></a>
Notes on conversion possibilities</h1>
<h2><a class="anchor" id="cell_vs_corner"></a>
Cell center versus cell corner values</h2>
<p>In all cases mentioned below, the difference between convert-types with or without <em>CC</em> relates to the difference between cell center (&lsquo;CC&rsquo;) versus cell corner values. For the cell center case, no interpolation of the computed data is needed, since the (conservative) variables actually represent volume averages stored at cell centers. For the other cases (without 'CC'), the <em>convert.t</em> tries to interpolate from cell center to the cell corners, and then the data will be known at the grid nodes. This will be noticable on reading in the data in <em>paraview</em>, which reports whether data is cell data (cell centered) or point data (nodes or corners). In principle, the conversion from cell centered (or cell data) to cell corner (or point data) types can also be achieved in paraview itself, with the filter <em>Cell data to Point data</em>. There may be subtle differences between the way MPI-AMRVAC does this interpolation, and the way it happens internally to paraview, so we provide both options as output <em>*.vtu</em> files. Similar observations hold for the Tecplot format.</p>
<h2><a class="anchor" id="cons_vs_prim"></a>
Conservative/primitive storage and adding derived quantities</h2>
<p>The <b>saveprim</b> logical allows you to select whether the conservative or primitive variables need to be stored in the resulting output file. The names for the conservative variables and primitive ones are hard coded depending on the physics.</p>
<p>Another very useful option is to specify which variables actually need to be converted: by default all conservative variables available in the <em>*.dat</em> file will be included, but then again filesizes may become restrictive. For that purpose, the logical array <em>w_write</em> allows to select which variable(s) to store (and this in combination with saveprim, possibly). You can then create different files for selected variables, knowing that the output filename will start with <em>base_filename</em>.</p>
<p>We allow the possibility to compute derived variables from the <em>*.dat</em> file in the userfile, by setting how many you add beyond the <em>nw</em> variables typcial for the physics module at hand, in the integer <em>nwauxio</em>. Correspondingly that many variables, you should then compute and store in the <em>w(*,nw+1)</em> ... <em>w(*,nw+nwauxio)</em> entries, in the user-written subroutine _ specialvar_output_ (as defined in <em><a class="el" href="mod__usr__methods_8t.html">mod_usr_methods.t</a></em>). The names for these variables then need to be provided in the corresponding <em>specialvarnames_output</em> subroutine. This feature is very useful, for the same reason as above: you can let the code compute gradients of scalar fields, divergence of vector quantities, curls of vectors, etc, using the precoded subroutines for that purpose found in <em>geometry.t</em>. You then do not rely on visualization software to do interpolations or discretizations, which may not reflect those actually taken in MPI-AMRVAC.</p>
<p>Another useful feature is the possibility to select the output AMR level. You can let the code compute from the <em>*.dat</em> file an output residing on a specified level <em>level_io</em>. This then uses the MPI-AMRVAC internal means to perform restriction and prolongations, and you can then make sure to have a single uniform grid output too.</p>
<h3><em>convert_type='vtu'</em> or <em>convert_type='vtuCC'</em></h3>
<p>Does the conversion to <em>*.vtu</em> data files. This option works on 1 CPU. The resulting <em>*.vtu</em> files contain data in ASCII format.</p>
<h3><em>convert_type='vtuB'</em> or <em>convert_type='vtuBCC'</em></h3>
<p>Does the conversion to <em>*.vtu</em> data files. This option works on 1 CPU. The resulting <em>*.vtu</em> files are in binary format.</p>
<h3><em>convert_type='vtumpi'</em> or <em>convert_type='vtuCCmpi'</em></h3>
<p>Does the conversion to <em>*.vtu</em> data files. This option works on multiple CPUs. The resulting <em>*.vtu</em> files contain data in ASCII format.</p>
<h3><em>convert_type='vtuBmpi'</em> or <em>convert_type='vtuBCCmpi'</em></h3>
<p>Does the conversion to <em>*.vtu</em> data files. This option works on multiple CPUs. The resulting <em>*.vtu</em> files contain data in binary format. (recommended)</p>
<h3><em>convert_type='tecplot'</em> or <em>convert_type='tecplotCC'</em></h3>
<p>This realizes conversion to <em>*.plt</em> files, which can be read in directly by Tecplot. Note that the output is in ASCII format, which may mean huge data sets, but Tecplot has its own <b>preplot</b> command that will allow you to operate on such a file, and thereby make a binary version for it. The above is for single CPU execution, allows to add user-defined variables with <em>nwauxio</em>, and renormalization using the <em>normt</em> and <em>normvar</em> array.</p>
<h3><em>convert_type='tecplotmpi'</em> or <em>convert_type='tecplotCCmpi'</em></h3>
<p>Same as above, but allows to perform the conversion in parallel. One can add user -defined variables with <em>nwauxio</em>, and renormalize using the <em>normt</em> and <em>normvar</em> array. The current implementation is such that tecplotmpi and tecplotCCmpi will create different length output ASCII files when used on 1 versus multiple CPUs. In fact, on 1 CPU, there will be as many (tecplot) zones as there are levels, while on on multiple CPUs, there will be a number of zones up to the number of levels times the number of CPUs (or less, when some level does not exist on a certain CPU).</p>
<h3>onegrid(mpi), oneblock(B), ...</h3>
<p>Extra possibilities to allow creation of a single uniform grid level output. Please inspect the workings in <em>convert.t</em>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
