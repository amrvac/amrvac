<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MPI-AMRVAC: Source language</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="my_customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MPI-AMRVAC
   &#160;<span id="projectnumber">3.0</span>
   </div>
   <div id="projectbrief">The MPI - Adaptive Mesh Refinement - Versatile Advection Code</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Source language </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="source_intro"></a>
Introduction</h1>
<p>This document describes the structure and the syntax of the <b>src/FILENAME.t</b> source files, and also provides explanation to the most common expressions. A brief summary at the end is provided as a quick reference guide.</p>
<p>A more general and possibly more enlightening description of the source language can be found in a paper on the <a href="http://www-personal.umich.edu/~gtoth/Papers/lasy.html">LASY Preprocessor</a>.</p>
<h1><a class="anchor" id="structure"></a>
Structure</h1>
<p>MPI-AMRVAC does both the initialization as well as the advancing of the variables in the governing PDEs. The program consists of several modules. Modules are simply sets of subroutines and functions that belong together and they are put in a single file.</p>
<p>The main program is in the file <b><a class="el" href="amrvac_8t.html">amrvac.t</a></b> and all time-advancing actually happens in <b><a class="el" href="mod__advance_8t.html">mod_advance.t</a></b>. Input and output routines are in the <b>amrvacio</b> directory which also contains the postprocess conversion part collected in <b><a class="el" href="convert_8t.html">convert.t</a></b>. Subroutines likely to be modified by the user are to be collected in the <b>mod_usr.t</b> module. In this module, you must at the very minimum define all global parameters and provide initial conditions for all (conserved) variables on the grid, by following the template provided in <b>mod_usr_template.t</b>.</p>
<p>Independence of equations is ensured by putting all flow variables in a single array <b>w</b>, and the variables are distinguished by their named indices, e.g. <b>w(ix1,ix2,rho_)</b> would read <b>rho(ix1,ix2)</b> in a typical code designed for a single equation. Here <b>rho_</b> is an integer parameter defined in the <b><a class="el" href="mod__rho__phys_8t.html">mod_rho_phys.t</a></b> module.</p>
<p>The physics modules have several variants, and they are found in the corresponding subdirectories called <b>rho</b> for advection, <b>hd</b> for hydro (plus dust) and <b>mhd</b> for MHD. All physics modules are available in the library version of AMRVAC, and the user has to active the module of choice for the application in mind.</p>
<p>The spatial discretization of the equations algorithms are spread over the modules <b><a class="el" href="mod__finite__volume_8t.html">mod_finite_volume.t</a></b>, <b><a class="el" href="mod__finite__difference_8t.html">mod_finite_difference.t</a></b>, <b><a class="el" href="mod__tvd_8t.html">mod_tvd.t</a></b> where limiter implementations are obtained from <b><a class="el" href="mod__mp5_8t.html">mod_mp5.t</a></b> <b><a class="el" href="mod__ppm_8t.html">mod_ppm.t</a></b> <b><a class="el" href="mod__limiter_8t.html">mod_limiter.t</a></b>.</p>
<p>The explicit temporal discretizations are in the main advancing module <b><a class="el" href="mod__advance_8t.html">mod_advance.t</a></b>.</p>
<p>The info on the grid related quantities is all in the <b>geometry.t</b> module.</p>
<h1><a class="anchor" id="syntax"></a>
Syntax</h1>
<ol type="1">
<li>Dimensions and vector components</li>
</ol>
<p>Since we aim to solve equations independent of the number of dimensions, arrays with unknown number of dimensions have to be declared and manipulated. This is achieved by the extensive use of the preprocessor VACPP.</p>
<p>The basic idea of the Loop Annotation Syntax (LASY) is defining loops in the source text. A first example may be an array with 3 indices: </p><pre class="fragment">    a({ix^D|,})   --&gt;     a(ix1,ix2,ix3)
</pre><p> The string <b>ix^D</b> between the **{** and **|** characters is repeated NDIM=3 times with the pattern string **^D** replaced by <b>1</b>, <b>2</b> and <b>3</b>, and the three resulting strings are separated by the string between the **|** and **}** characters, in this case a single comma. As you may observe, some special characters are used to help the preprocessor in recognizing the loop. The loop is enclosed between curly brackets, the pattern consists of a **^** character followed by uppercase letters (or <b>%</b>, or <b>&amp;</b>), and the separator string is preceded by the **|** character. Thus the full syntax of the loop is </p><pre class="fragment">    { text ^PATTERN text ^PATTERN ... | separator }
</pre><p> Fortunately some default values can be introduced to simplify the notation. The default separator is the comma, thus the above example can be written as <b>a({ix^D})</b>. Furthermore the preprocessor can expand patterns without enclosing curly brackets. When it sees a pattern, it looks for <em>bounding characters</em> on both sides. These are one of <em>comma, space, newline, semicolon</em> and <em>enclosing parentheses</em>. Since our **^D** pattern is enclosed by a left and a right parenthesis, we may simply type </p><pre class="fragment">    a(ix^D)
</pre><p> which will expand to <b>a(ix1)</b>, <b>a(ix1,ix2)</b>, and <b>a(ix1,ix2,ix3)</b> for the choices NDIM=1, 2, and 3, respectively.</p>
<p>The curly brackets are used only when the repetition should expand over some bounding characters. The required separator is very often a single character, such as in the calculation of sums or products: </p><pre class="fragment">    ix^D*    --&gt;   ix1*ix2*ix3
</pre><p> Here the **^D** pattern is enclosed by a new line and a space character, and the preprocessor checks the last character of the repeated string. If it is one of comma, space, <b>+</b>, <b>-</b>, *****, **/**, **:**, **;**, or ****, it is taken to be a separator character. The **** is replaced by a new line. A simple use may be nested DO loops: </p><pre class="fragment">{do ix^D=1,100 \ }
    a(ix^D)= ix^D*
{enddo\ }
</pre><p> which translates to: </p><pre class="fragment">do ix1=1,100
do ix2=1,100
    a(ix1,ix2)= ix1*ix2
enddo
enddo
</pre><p> Here NDIM=2 was assumed. Note the need for curly brackets in the first line to override the space and the comma, and also note the space in <b>a(ix^D)= ix^D*** which is needed to bound the **ix^D*** loop. In the final **{enddo\ }</b> line the number of repetitions was assumed to be NDIM, as we shall see this may not always be the case.</p>
<p>Suppose we want to assign the same value to NDIM variables: </p><pre class="fragment">    ix^D=1;     --&gt;     ix1=1;ix2=1;
</pre><p> The semicolon is a bounding character, thus strictly speaking it does not belong to the <b>ix^D=1</b> loop. The preprocessor, however, checks wether the right bounding character is a semicolon, and if it is, it becomes the separator. The original trailing semicolon is also preserved, which turns out to be a useful feature.</p>
<p>Up to this point we used a single pattern **^D** only, which is replaced by the numbers <b>1..NDIM</b>. During the code development it became obvious that the preprocessor can be used for many other things than repeated indices for the dimensions. The first new application is the components for vector variables, which run from 1 to NDIR, and in general 1&lt;=NDIM&lt;=NDIR&lt;=3. When more than one pattern is found in a loop, the first one determines the number of repetitions, and only patterns with the same first letter are replaced by their substitutes.</p>
<p>Look at the following typical case construct for NDIM=2: </p><pre class="fragment">select case(iw)
  {case(mom(^D))
     mom(ixmin^D:ixmax^D)=w(ixmin^D:ixmax^D,mom(^D)) \ }
end select

--&gt;

select case(iw)
  case(mom(1))
     mom(ixmin^D:ixmax^D)=w(ixmin^D:ixmax^D,mom(1))
  case(mom(2))
     mom(ixmin^D:ixmax^D)=w(ixmin^D:ixmax^D,mom(2))
end select

--&gt;

select case(iw)
  case(mom(1))
     mom(ixmin1:ixmax1,ixmin2:ixmax2)=&amp;
        w(ixmin1:ixmax1,ixmin2:ixmax2,mom(1))
  case(mom(2))
     mom(ixmin1:ixmax1,ixmin2:ixmax2)=&amp;
        w(ixmin1:ixmax1,ixmin2:ixmax2,mom(2))
end select
</pre><p> Notice that the preprocessor first expanded the loop for the first **^D** pattern and substituted **^D** in the third index of the <b>w</b> array but the other indices with the **^D** patterns were left alone. In the second iteration the loops with **^D** patterns were expanded. The resulting lines may become extremely long, thus the preprocessor breaks them into continuation lines.</p>
<h4></h4>
<ol type="1">
<li>Limits, segments, and nulpatterns</li>
</ol>
<p>To further shorten the notation the often used <b>min^D</b> and <b>max^D</b> strings were interpreted as a loop of the **^L** pattern (mnemonic: Limits). Yes, a pattern may expand into other pattern(s) thus producing another loop. To declare the limits of the array sections one may say </p><pre class="fragment">    integer:: ix^L  --&gt;  integer:: ixmin^D,ixmax^D  --&gt;

integer:: ixmin1,ixmin2,ixmax1,ixmax2
</pre><p> The intermediate **^D** pattern becomes very important in the following typical example: </p><pre class="fragment">    jx^L=ix^L+kr(idim,^D);                                       --&gt;

jxmin^D=ixmin^D+kr(idim,^D);jxmax^D=ixmax^D+kr(idim,^D);     --&gt;

jxmin1=ixmin1+kr(idim,1);jxmin2=ixmin2+kr(idim,2);
jxmax1=ixmax1+kr(idim,1);jxmax2=ixmax2+kr(idim,2);
</pre><p> The purpose is to shift the limits by 1 in the idim direction. The <b>kr</b> array is a Kronecker delta, it is 1 for the diagonal elements where the two indices are the same, and 0 otherwise. The <b>j</b> in the <b>jx</b> is the next letter in the alphabet after the <b>i</b>, thus <b>jx</b> is the mnemonic for <b>ix****+****1</b>. Similarly <b>hx</b> is consistently used for <b>ix****-****1</b>. The semicolon remains the separator for both loop expansions thanks to the trailing semicolon in the intermediate step. Also note that the parentheses of <b>kr(idim,^D)</b> do not bound the initial loop for <b>jx^L=...</b> because they do not enclose it. Once we get used to the notation it becomes natural to think of an <b>ix^L</b> type loop as a Pascal record or C structure consisting of 2, 4 or 6 integers. Therefore **^LADD**, **^LSUB** and **^LT** are introduced to do operations and comparisons on them. **^LADD** (mnemonic: add to limits) is replaced by <b>-</b> and <b>+</b> to decrease lower and increase upper limits, **^LSUB** does the opposite by expanding to <b>+</b> and <b>-</b>, finally **^LT** has substitutes <b>&gt;</b> and <b>&lt;</b> ensuring that the limits on the left are within the limits on the right. Thus we may extend the <b>ix^L</b> limits by 1 with </p><pre class="fragment">    ix^L=ix^L^LADD1;  --&gt;  ixmin^D=ixmin^D-1;ixmax^D=ixmax^D+1;

ixmin1=ixmin1-1;ixmin2=ixmin2-1;ixmax1=ixmax1+1;ixmax2=ixmax2+1;
</pre><p> To check if the <b>ixI^L</b> input limits are not narrower than the <b>ix^L</b> limits </p><pre class="fragment">    if(ixI^L^LTix^L|.or.|.or.)stop --&gt;

if(ixImin^D&gt;ixmin^D|.or. .or. ixImax^D&lt;ixmax^D|.or.)stop  --&gt;

if(ixImin1&gt;ixmin1.or.ixImin2&gt;ixmin2 .or. ixImax1&lt;ixmax1.or.&amp;
   ixImax2&lt;ixmax2)stop
</pre><p> where note the repeated use of the **.or.** separator string.</p>
<p>It is possible to form array sections from the **^L** pattern by making use of the **:** as a separator, but it turns out that introducing the new patterns **^LIM** (mnemonic: three letter LIMits min and max) and **^S** (mnemonic: Sections) is a better solution. The typically internally used **^LIM** pattern expands to <b>min</b> and <b>max</b>, while **^S** expands to **^LIM1:..^LIMndim:**, and therefore </p><pre class="fragment">    a(ix^S)  --&gt;  a(ix^LIM1:,ix^LIM2:)  --&gt;  a(ixmin1:ixmax1,ixmin2:ixmax2)
</pre><p> As you may suspect the whole exercise of introducing **^LIM** and **^S** served the purpose of achieving this extremely compact notation for array sections. In array declarations the <b>lo</b> and <b>hi</b> absolute limits are used instead of the <b>min</b> and <b>max</b> actual limits. The **^LL** pattern (mnemonic: Lowest/highest Limits) thus expands to <b>lo^D</b> and <b>hi^D</b> similarly to **^L**, while **^LLIM** gives simply <b>lo</b> and <b>hi</b>, and **^T** (mnemonic: total segment) is used in most array declarations: </p><pre class="fragment">    a(ix^T)  --&gt;  a(ix^LLIM1:,ix^LLIM2:)  --&gt;  a(ixlo1:ixhi1,ixlo2:ixhi2)
</pre><p> Now that we have many different patterns with different number of substitutes it becomes useful and necessary to introduce patterns which are replaced by nulstrings, but they determine the number and kind of substitutions. The **^D&amp;** and **^C&amp;** patterns produce NDIM and NDIR repetitions respectively. (The alternative names ^DLOOP and ^CLOOP can also be used to avoid syntax problems at the end of a line, where the &amp; means continuation according to FORTRAN 90.) A trivial application is the enddo-s at the end of NDIM nested do loops: </p><pre class="fragment">    enddo^D&amp;;     --&gt;    enddo;enddo;
</pre><p> Obviously the **^D** pattern would not work here: <b>enddo^D; &ndash;&gt; enddo1;enddo2;</b>. For scalar products of vector variables the **^D&amp;** is used at the head of the loops to tell VACPP that first the **^D** patterns should be expanded.</p>
<h4></h4>
<ol type="1">
<li>Breaking the symmetry</li>
</ol>
<p>The symmetry of the indices is sometimes broken. In the code it is mostly related to the assumption of axial symmetry, when the first dimension becomes special. The rest of the dimensions and sections are expanded from the **^DE** (mnemonic: Dimensions Extra) and **^SE** (Sections Extra) patterns. The radial distance may be related to the <b>x</b> coordinate array by </p><pre class="fragment">    r(ix^LIM1:)=x(ix^LIM1:,ixmin^DE,1)   --&gt;

r(ixmin1:ixmax1)=x(ixmin1:ixmax1,ixmin2,ixmin3,1)
</pre><p> then <b>r</b> may be a weight function for an array </p><pre class="fragment">    forall(ix= ix^LIM1:) a(ix,ix^SE)=r(ix)*a(ix,ix^SE)      --&gt;

forall(ix= ixmin1:ixmax1) a(ix,ixmin2:ixmax2)=r(ix)*a(ix,ixmin2:ixmax2)
</pre><p> If NDIM=1 the preprocessor removes the separator, in this case a comma in the <b>ix,ix^SE</b> string, and the <b>ix^SE</b> loop is repeated 0 times, thus we get <b>forall(ix= ixmin1:ixmax1) a(ix)=r(ix)*a(ix)</b> as expected.</p>
<p>Another type of symmetry breaking occurs when something is done for all the indices separately, e.g. the boundary elements of an NDIM dimensional array are filled up for each boundary separately. The **^D%** pattern is replaced by **^%1..^NDIM** patterns. The **^N** pattern substitutes the text in front of it in the N-th repetition, and the text behind in the other substitutions. In general <b>head^Ntail &ndash;&gt; tail,..,tail,head,tail,..,tail</b> with <b>head</b> being at the N-th position. The number of repetitions is determined by the first pattern in <b>head</b> and <b>tail</b>. Here is an application for boundary conditions with <b>ixB^L</b> enclosing the boundary region and <b>ixMmin^D</b> being the edge of the mesh: </p><pre class="fragment">    {case(^D)
   do ix= ixBmin^D,ixBmax^D
      a(ix^D%ixB^S)=a(ixMmin^D^D%ixB^S)
   end do \ }

--&gt; /loop for ^D/

case(1)
   do ix= ixBmin1,ixBmax1
      a(ix^%1ixB^S)=a(ixMmin1^%1ixB^S)
   end do
case(2)
   do ix= ixBmin2,ixBmax2
      a(ix^%2ixB^S)=a(ixMmin2^%2ixB^S)
   end do

--&gt; /loops for ^S taking ^%1 and ^%2 into account/

case(1)
   do ix= ixBmin1,ixBmax1
      a(ix,ixB^LIM2:)=a(ixMmin1,ixB^LIM2:)
   end do
case(2)
   do ix= ixBmin2,ixBmax2
      a(ixB^LIM1:,ix)=a(ixB^LIM1:,ixMmin2)
   end do

--&gt; /loops for ^LIM/

case(1)
   do ix= ixBmin1,ixBmax1
      a(ix,ixBmin2:ixBmax2)=a(ixMmin1,ixBmin2:ixBmax2)
   end do
case(2)
   do ix= ixBmin2,ixBmax2
      a(ixBmin1:ixBmax1,ix)=a(ixBmin1:ixBmax1,ixMmin2)
   end do
</pre> <h4></h4>
<ol type="1">
<li>Special features: dimensional switches</li>
</ol>
<p>Depending on the actual use of MPI-AMRVAC some subroutines may or may not be present, so something where you really need to use a 1D construct is best embedded as </p><pre class="fragment">    {^IFONED   (something where x(ix1) occurs e.g.) }
</pre><p> This should be done with care, as the idea of the code is to use it for any dimensionality. Still, certain subroutines are not used at all in 1D, or they may be needed only in 2D, and the **^NOONED**, **^IFTWOD** etc. switches are then used to make a part of the code conditional on the value of the NDIM parameter.</p>
<h2>Summary</h2>
<ol type="1">
<li>VACPP Patterns</li>
</ol>
<p>We assume NDIM=2, so you may try this interactively with <b>vacpp.pl -d=2</b>. For a full list of defined patterns read the <b>&amp;patdef</b> definitions in <b>vacpp.pl</b>. </p><pre class="fragment">    Pattern   Substitutes                              Mnemonic

* * *

^D    --&gt; 1,2                                      Dimensions
^DE   --&gt; 2                                        Dimensions Extra
^D&amp;   --&gt; ,                                        NDIM repetitions
^DLOOP--&gt; ,                                           NDIM repetitions
^DD   --&gt; ^D,^D           --&gt; 1,2,1,2              NDIM*NDIM dimensions
^D%   --&gt; ^%1,^%2         --&gt; head,tail,tail,head  NDIM*NDIM head-tail matrix
^C    --&gt; 1,2,3                                    Components
^C&amp;   --&gt; ,,                                       NDIR repetitions
^CLOOP--&gt; ,,                                           NDIR repetitions
^L    --&gt; min^D,max^D     --&gt; min1,min2,max1,max2  Limits in all D
^LIM  --&gt; min,max                                  LIMits min and max
^LLIM --&gt; lo,hi                                    Low and high LIMits
^LADD --&gt; -,+                                      Add to ^L (extend)
^LSUB --&gt; +,-                                      Subtract from ^L (shrink)
^LT   --&gt; &gt;,&lt;                                      Less Than (compare ^L)
^LL   --&gt; lo^D,hi^D       --&gt; lo1,lo2,hi1,hi2      Lowest/highest Limits
^S    --&gt; ^LIM1:,^LIM2:   --&gt; min1:max1,min2:max2  Segments
^SE   --&gt; ^LIM2:          --&gt; min2:max2            Segments Extra
^T    --&gt; ^LLIM1:,^LLIM2: --&gt; lo1:hi1,lo2:hi2      Total segments

* * *
</pre> <h4></h4>
<ol type="1">
<li><p class="startli">VACPP Expressions</p>
<p class="startli">Source VACPP notation Expanded Fortran 90 code</p>
</li>
</ol>
<hr  />
<p>integer:: ix^D --&gt; integer:: ix1,ix2</p>
<p>integer:: ix^L --&gt; integer:: ixmin1,ixmin2,ixmax1,ixmax2</p>
<p>real:: w(ixG^T,nw) --&gt; real:: w(ixGlo1:ixGhi1,ixGlo2:ixGhi2,nw)</p>
<p>call subr(w,ix^L) --&gt; call subr(w,ixmin1,ixmin2,ixmax1,ixmax2)</p>
<p>ixI^L=ix^L^LADD1; --&gt; ixImin1=ixmin1-1;ixImin2=ixmin2-1; ixImax1=ixmax1+1;ixImax2=ixmax2+1;</p>
<p>jx^L=ix^L+kr(2,^D); --&gt; jxmin1=ixmin1+kr(2,1);jxmin2=ixmin2+kr(2,2); jxmax1=ixmax1+kr(2,1);jxmax2=ixmax2+kr(2,2);</p>
<p>{^IFTWOD text} --&gt; text or '' (depending on ndim being equal to 2)</p>
<p>{^NOONED text} --&gt; '' or text (depending on ndim being equal to 1}</p>
<hr  />
 </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
