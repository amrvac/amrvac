<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MPI-AMRVAC: Discretization</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="my_customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MPI-AMRVAC<span id="projectnumber">&#160;3.1</span>
   </div>
   <div id="projectbrief">The MPI - Adaptive Mesh Refinement - Versatile Advection Code</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Discretization</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="disc-intro"></a>
Introduction</h1>
<p>This document briefly describes how the equations are discretized.</p>
<h1><a class="anchor" id="disc-eq"></a>
Equations</h1>
<p>MPI-AMRVAC aims to solve a system of partial differential equations of the form </p><pre class="fragment">dw/dt=-dF_i(w)/dx_i+S(w)=R(w)
</pre><p> where w is a vector of <b>iw=1..nw</b> flow variables, <b>F_i</b> are fluxes in <b>idim=1..ndim</b> directions for each <b>w</b>, and <b>S</b> is the source including all terms which are not described by <b>F_i</b>. The flux and source terms together are denoted by <b>R</b>. The discretization is of a finite volume kind, where cell-centered quantities represent cell-averaged densities for conservative variables.</p>
<h1><a class="anchor" id="disc-splitting"></a>
Dimensional and Source Splitting</h1>
<p>Some methods were originally designed to handle 1D problems, they may be best applied to multidimensional problems by splitting the equation for the derivatives of the flux, and solving the split equations in subsequent sweeps. All these strategies are handled in the <em><a class="el" href="mod__advance_8t.html">mod_advance.t</a></em> module.</p>
<p>For a forward Euler time integration scheme the above equation can be discretised in time as </p><pre class="fragment">w^(n+1)    = [I+dt*(Fx+Fy+Fz+S)] w^n
</pre><p> where Fx, Fy, and Fz are short notations for the dF_i/dx_i terms for 3D.</p>
<p>Dimensional splitting means the following approximations: </p><pre class="fragment">I+dt*(Fx+Fy+S)    --&gt; [I+dt*(Fx+S/2)] [I+dt*(Fy+S/2)]                   (2D)

I+dt*(Fx+Fy+Fz+S) --&gt; [I+dt*(Fx+S/3)] [I+dt*(Fy+S/3)] [I+dt*(Fz+S/3)]   (3D)
</pre><p> In case <b>dimsplit=T</b>, the default splitting strategy is according to <b>typedimsplit='xyyx'</b>, which ensures alternation in the order of the sweeps in every second time step. This alternation can be switched off by <b>typedimsplit='xy'</b> which may be useful for steady state calculations. Depending on the selected scheme, we can also invoke no dimensional splitting at all, hence <b>dimsplit=F</b> (which implies <b>typedimsplit='unsplit'</b>).</p>
<p>The source terms S may also be separated from the fluxes F. A reason to use split source terms may arise, when the sources are stiff, or unstable for an explicit evaluation. For steady state evolutions, one would typically use unsplit sources and no dimensional splitting at all. Splitting user sources from fluxes is achieved by <b>source_split_usr=T</b>. How sources are then added depends on <b>typesourcesplit</b>, which can be any of 4 pre-implemented combinations.</p>
<p>Setting <b>typesourcesplit='sfs'</b> results in </p><pre class="fragment">I+dt*(Fx+Fy+Fz+S) --&gt; [I+dt/2*S] [I+dt*(Fx+Fy+Fz)] [I+dt/2*S]
</pre><p> for the dimensionally unsplit case, and </p><pre class="fragment">I+dt*(Fx+Fy+S)    --&gt; [I+dt/2*S] [I+dt*Fx] [I+dt*Fy] [I+dt/2*S]            (2D)

I+dt*(Fx+Fy+Fz+S) --&gt; [I+dt/2*S] [I+dt*Fx] [I+dt*Fy] [I+dt*Fz] [I+dt/2*S]  (3D)
</pre><p> for the dimensionally split case. To achieve second order time accuracy, the numerical representation of the source term <b>S</b> should be second order accurate in time. In case of special source terms written by the user, this may be achieved by implementing in the pointed <b>usr_source</b> subroutine.</p>
<p>However a simple second order Runge-Kutta evaluation is already built in. Setting <b>typesourcesplit='ssfss'</b> gives the following evaluation for <b>w_S = [I+dt/2*S] w</b>: </p><pre class="fragment">w_1 = w + dt/4 S(w)
w_S = w + dt/2 S(w_1)
</pre><p> both at the beginning and at the end of the time step, otherwise the default <b>w_S = w + dt/2 S(w)</b> is used. Other choices for <b>typesourcesplit</b> are **'sf', 'ssf'**.</p>
<h1><a class="anchor" id="disc-time"></a>
Time Discretization</h1>
<p>The code can use a variety of <a class="el" href="md_doc_2methods.html">methods</a> for spatial discretization of fluxes. A method is applied to all variables on a specific AMR level, but the method may differ from grid level to grid level. As we saw in the previous section, the contribution of the fluxes (dimensionally split or unsplit, with or without the source terms) need to be evaluated to at least 2nd order accuracy in time. Let <b>R</b> denote the general operator that represents any of the Fx, (Fz+S/3), (Fx+Fy), (Fx+Fy+Fz+S), etc. terms that arise in the equations above depending on the number of dimensions and on the dimensional and source splitting parameters.</p>
<p>There are many options to evaluate <b>w_R=[I+dt*R] w</b>, it is determined by the value of the <b>time_stepper</b> (and the <b>time_integrator</b>) parameter with the following examples: </p><pre class="fragment">w_R = w + dt*R(w)                 'onestep'

w_1 = w + dt/2*R1(w)               'twostep'  (predictor step)
w_R = w + dt  *R(w_1)                        (corrector step)

w_1 = w + dt/2*R(w)               'fourstep' (classical RK4 when `time_integrator='rk4'`)
w_2 = w + dt/2*R(w_1)
w_3 = w + dt  *R(w_2)
w_4 = w + dt/6*R(w_3)
w   = w + dt/6*[R(w_1)+2*R(w_2)+2*R(w_3)+R(w_4)]
</pre><p> The time stepper and integrator RK4 is fourth order accurate. Not all schemes can be combined with all options, infact the TVD scheme should use <b>time_integrator='onestep'</b>. Most methods like TVDLF, TVD-MUSCL, HLL, HLLC can use <b>time_stepper='twostep'</b> or <b>time_stepper='threestep'</b> or even 'fourstep' or 'fivestep'. For consistency, the accuracy of the time integrator should have the same order as the slope limiter's accuracy. 3rd order accurate time integrators are found within the 'threestep' options, with its default 'ssprk3' as <b>time_integrator</b>. 4th order accurate time steppers/integrators include 'fourstep' with 'rk4', or 'fivestep' with its default 'ssprk5'. Various SSPRK schemes are found under the 'twostep', 'threestep', 'fourstep' and 'fivestep' time_steppers.</p>
<p>Since in the twostep method the <b>R1</b> spatial discretization in the first <em>predictor</em> step can be different from <b>R</b> of the second <em>corrector</em> step, the twostep time integration is a predictor-corrector type scheme. In the parameter file, the arrays <b>typepred1</b> and <b>flux_scheme</b> (which need to be specified for each AMR grid level up to <b>nlevelshi</b>), determine the method applied in the predictor and full step.</p>
<p>For the multistep RK4 integration scheme, the same <b>flux_scheme</b> method is used in each substep for <b>istep=1..nstep</b>. Full timesteps are counted by <b>it_init &lt;= it &lt;= it_max</b>, while the physical time is <b>global_time &lt;= time_max</b>.</p>
<h1><a class="anchor" id="disc-grid"></a>
Grid and Mesh</h1>
<p>The grid is a 1, 2 or 3D grid, either Cartesian, cylindrical (to which polar belongs), or spherical, which is selected by call <code>set_coordinate_system</code> in <code>usr_init</code> subroutine of <code>mod_usr.t</code>. See <a class="el" href="md_doc_2axial.html">coordinate system</a> for more information. The coordinates of the grid points are represented by the array <b>x</b>, usually interpreted for Cartesian coordinates as x, y, and z; for cylindrical as r, z, and phi; for polar grid as r, phi, and z; for spherical grid as r, theta, and phi. Other useful cell-related quantities calculated from <b>x</b>, like distance between cell interfaces, volume, surface, and surface normal, are also computed, and this happens in the <em>geometry.t</em> module, specifically in the <em>fillgeo</em> subroutine. They are stored in the structures <em>pw(igrid)surfaceC(ixG^T,^D)</em>, <em>pw(igrid)surface(ixG^T,^D)</em>, <em>pw(igrid)dvolume</em> and <em>pw(igrid)dx</em>.</p>
<p>The spatial indices of these arrays, denoted by the dimension independent <a class="el" href="md_doc_2source.html">syntax</a>, have varying ranges, depending on their use (as cell centered, or cell surface quantities). Remember that number of physical cells (by <em>block_nx^D</em>) plus number of ghostcells (by <em>nghostcells</em>) gives the total grid extent: </p><pre class="fragment">ixGlo^D:ixGhi^D = ixG^T
</pre><p> In many places, the same range, including ghost cells describing the boundaries, is denoted as </p><pre class="fragment">ixGmin^D:ixGmax^D = ixG^S
</pre><p> The mesh is defined as the grid without boundary layers: </p><pre class="fragment">ixMlo^D,ixMhi^D = ixGlo^D+nghostcells,ixGhi^D-nghostcells
</pre><p> or equivalently as ixMmin^D,ixMmax^D, or in a shorter notation </p><pre class="fragment">ixM^L = ixG^L^LSUBnghostcells^L
</pre><p> The ghost cells are updated by the subroutine <code>getbc</code> in <code><a class="el" href="mod__ghostcells__update_8t.html">mod_ghostcells_update.t</a></code>. When a file is read or saved by MPI-AMRVAC, the ghost cells are usually not included.</p>
<p>You may run the <a class="el" href="md_doc_2vacpp.html">VACPP</a> preprocessor interactively to see how the above expressions are translated for a given number of dimensions.</p>
<h1><a class="anchor" id="disc-boundaries"></a>
Boundary Regions</h1>
<p>The boundary cells of the grid are grouped into boundary regions indexed by <b>iB=1..nB</b>. In 1D, there are 2 regions, at left and right of the mesh; in 2D there are 4, left, right, bottom, top (in that order); while for 3D there are</p><ol type="1">
<li>These boundary regions cover the <b>2*ndim</b> edges of the grid in the <em>left, right, bottom, top, front, back</em>, in other words, <em>ixmin1, ixmax1, ixmin2, ixmax2, ixmin3, ixmax3</em>, order. The regions overlap at the corner ghost cells.</li>
</ol>
<p>The boundary methods are applied to each boundary region from <b>iB=1</b> to <b>nB</b> and for each variable from <b>iw=1</b> to <b>nw</b> according to the descriptor string <b>typeboundary(iw,iB)</b>. An exception is made for the <b>special</b> type variables, where all variables should be provided somehow in conservative format by users in pointed <code>usr_special_bc</code> subroutine in <code>mod_usr.t</code>.</p>
<p>Please note that the boundary itself is at the interface between the real and ghost cells, therefore setting the velocity to 0 in the ghost cell will not make the velocity 0 at the cell interface which is an interpolated value. To have exactly zero flux through the boundary, the **'symm'** boundary type should be used for the scalar quantities and the tangential velocity components. For the normal vector components the anti-symmetric **'asymm'** boundary type should be used.</p>
<h2><a class="anchor" id="disc-internal"></a>
Internal boundaries</h2>
<p>Internal boundaries can be used to overwrite the domain variables with specified values. Internally, these are assigned before the ghost-cells and external boundaries are applied (in subroutine <code>get_bc</code>). The user can provide conditions on the conserved variables depending on location or time in the pointed <code>usr_internal_bc</code> subroutine. To activate internal boundaries, the switch </p><pre class="fragment">internalboundary=.true.
</pre><p> has to be set in the <em>boundlist</em> section of the par file. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
